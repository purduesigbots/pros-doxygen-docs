<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classpros_1_1rtos_1_1Mutex" kind="class" language="C++" prot="public">
    <compoundname>pros::rtos::Mutex</compoundname>
    <includes refid="rtos_8hpp" local="yes">rtos.hpp</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="group__cpp-rtos_1gabbacf876372ff9592f15777f84cb2663" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; std::remove_pointer_t&lt; <ref refid="group__c-rtos_1gab15ea84d90257d70b44e8e04519864d2" kindref="member">mutex_t</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt;std::remove_pointer_t&lt;mutex_t&gt; &gt; mutex</definition>
        <argsstring></argsstring>
        <name>mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="824" column="17" bodyfile="pros/rtos.hpp" bodystart="824" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="group__cpp-rtos_1ga4b5dfbd24f5bc4c03b24b2da362f66d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>()</argsstring>
        <name>Mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="827" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gab09ea253b1dc6a2cf2543f9069af47f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>(const Mutex &amp;)=delete</argsstring>
        <name>Mutex</name>
        <param>
          <type>const <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="831" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gadd07188ea12392103ecbecf2215d603a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>(Mutex &amp;&amp;)=delete</argsstring>
        <name>Mutex</name>
        <param>
          <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="832" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaf883e9f2816275bfb96356ebab8343a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        <definition>Mutex&amp; operator=</definition>
        <argsstring>(const Mutex &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="834" column="7"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga346fc4a9a9db604140fb5e77e4ecf793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        <definition>Mutex&amp; operator=</definition>
        <argsstring>(Mutex &amp;&amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="835" column="7"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga520dfb72e1768ce08292ca08662c66a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool take</definition>
        <argsstring>()</argsstring>
        <name>take</name>
        <briefdescription>
<para>Takes and locks a mutex indefinetly. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes">https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes</ulink> for details.</para>
<para><simplesect kind="return"><para>True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn&apos;t be taken</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="917" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga4ed04a4dfdab9c125ecd5b87e1d31ac7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool take</definition>
        <argsstring>(std::uint32_t timeout)</argsstring>
        <name>take</name>
        <param>
          <type>std::uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting for up to a certain number of milliseconds before timing out. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes">https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes</ulink> for details.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the mutex becomes available. A timeout of 0 can be used to poll the mutex. TIMEOUT_MAX can be used to block indefinitely.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn&apos;t be taken.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1005" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga89e3741a62333612b1a98074ec17c7bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool give</definition>
        <argsstring>()</argsstring>
        <name>give</name>
        <briefdescription>
<para>Unlocks a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes">https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes</ulink> for details.</para>
<para><simplesect kind="return"><para>True if the mutex was successfully returned, false otherwise. If false is returned, then errno is set with a hint about why the mutex couldn&apos;t be returned.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1087" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa81aed607133209dade63a226818224d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void lock</definition>
        <argsstring>()</argsstring>
        <name>lock</name>
        <briefdescription>
<para>Takes and locks a mutex, waiting for up to TIMEOUT_MAX milliseconds. </para>
        </briefdescription>
        <detaileddescription>
<para>Effectively equivalent to calling pros::Mutex::take with TIMEOUT_MAX as the parameter.</para>
<para>Conforms to named requirment BasicLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/BasicLockable">https://en.cppreference.com/w/cpp/named_req/BasicLockable</ulink></para>
</simplesect>
<simplesect kind="note"><para>Consider using a std::unique_lock, std::lock_guard, or std::scoped_lock instead of interacting with the <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> directly.</para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::system_error</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> could not be locked within TIMEOUT_MAX milliseconds. see errno for details.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1173" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga9278be8203e1c42e2619179882ae4403" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void unlock</definition>
        <argsstring>()</argsstring>
        <name>unlock</name>
        <briefdescription>
<para>Unlocks a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to calling pros::Mutex::give.</para>
<para>Conforms to named requirement BasicLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/BasicLockable">https://en.cppreference.com/w/cpp/named_req/BasicLockable</ulink></para>
</simplesect>
<simplesect kind="note"><para>Consider using a std::unique_lock, std::lock_guard, or std::scoped_lock instead of interacting with the <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> direcly.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1255" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa24a64f788f142df670c3abc809d32b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool try_lock</definition>
        <argsstring>()</argsstring>
        <name>try_lock</name>
        <briefdescription>
<para>Try to lock a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns immediately if unsucessful.</para>
<para>Conforms to named requirement Lockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/Lockable">https://en.cppreference.com/w/cpp/named_req/Lockable</ulink></para>
</simplesect>
<simplesect kind="return"><para>True when lock was acquired succesfully, or false otherwise.</para>
</simplesect>
<ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">pros::Mutex</ref> mutex;</para>
<para>void my_task_fn(void* param) { while (true) { if(mutex.try_lock()) { printf(&quot;Mutex aquired successfully!\n&quot;); // Do stuff that requires the protected resource here } else { printf(&quot;Mutex not aquired!\n&quot;); } } } </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1281" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga710a8b20e993bf1c74bf40f1ecce0a73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Rep</type>
          </param>
          <param>
            <type>typename Period</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool try_lock_for</definition>
        <argsstring>(const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</argsstring>
        <name>try_lock_for</name>
        <param>
          <type>const std::chrono::duration&lt; Rep, Period &gt; &amp;</type>
          <declname>rel_time</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting for a specified duration. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to calling pros::Mutex::take with a duration specified in milliseconds.</para>
<para>Conforms to named requirement TimedLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">https://en.cppreference.com/w/cpp/named_req/TimedLockable</ulink></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rel_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the mutex becomes available. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the lock was acquired succesfully, otherwise false.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(mutex.try_lock_for(std::chrono::milliseconds(100)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>aquired<sp/>successfully!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>stuff<sp/>that<sp/>requires<sp/>the<sp/>protected<sp/>resource<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>not<sp/>aquired<sp/>after<sp/>100<sp/>milliseconds!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1311" column="6" bodyfile="pros/rtos.hpp" bodystart="1311" bodyend="1313"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga41a3a30923d0f6c41a70812ef37db9bb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Duration</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool try_lock_until</definition>
        <argsstring>(const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_time)</argsstring>
        <name>try_lock_until</name>
        <param>
          <type>const std::chrono::time_point&lt; <ref refid="structpros_1_1rtos_1_1Clock" kindref="compound">Clock</ref>, Duration &gt; &amp;</type>
          <declname>abs_time</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting until a specified time. </para>
        </briefdescription>
        <detaileddescription>
<para>Conforms to named requirement TimedLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">https://en.cppreference.com/w/cpp/named_req/TimedLockable</ulink></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>abs_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point until which to wait for the mutex. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the lock was acquired succesfully, otherwise false.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>the<sp/>current<sp/>time<sp/>point</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>auto<sp/>now<sp/>=<sp/>std::chrono::system_clock::now();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculate<sp/>the<sp/>time<sp/>point<sp/>100<sp/>milliseconds<sp/>from<sp/>now</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>auto<sp/>abs_time<sp/>=<sp/>now<sp/>+<sp/>std::chrono::milliseconds(100);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(mutex.try_lock_until(abs_time))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>aquired<sp/>successfully!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>stuff<sp/>that<sp/>requires<sp/>the<sp/>protected<sp/>resource<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>not<sp/>aquired<sp/>after<sp/>100<sp/>milliseconds!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1346" column="6" bodyfile="pros/rtos.hpp" bodystart="1346" bodyend="1348"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="pros/rtos.hpp" line="823" column="12" bodyfile="pros/rtos.hpp" bodystart="823" bodyend="1350"/>
    <listofallmembers>
      <member refid="group__cpp-rtos_1ga89e3741a62333612b1a98074ec17c7bc" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>give</name></member>
      <member refid="group__cpp-rtos_1gaa81aed607133209dade63a226818224d" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>lock</name></member>
      <member refid="group__cpp-rtos_1ga4b5dfbd24f5bc4c03b24b2da362f66d5" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>Mutex</name></member>
      <member refid="group__cpp-rtos_1gab09ea253b1dc6a2cf2543f9069af47f2" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>Mutex</name></member>
      <member refid="group__cpp-rtos_1gadd07188ea12392103ecbecf2215d603a" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>Mutex</name></member>
      <member refid="group__cpp-rtos_1gabbacf876372ff9592f15777f84cb2663" prot="private" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>mutex</name></member>
      <member refid="group__cpp-rtos_1gaf883e9f2816275bfb96356ebab8343a9" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>operator=</name></member>
      <member refid="group__cpp-rtos_1ga346fc4a9a9db604140fb5e77e4ecf793" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>operator=</name></member>
      <member refid="group__cpp-rtos_1ga520dfb72e1768ce08292ca08662c66a7" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>take</name></member>
      <member refid="group__cpp-rtos_1ga4ed04a4dfdab9c125ecd5b87e1d31ac7" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>take</name></member>
      <member refid="group__cpp-rtos_1gaa24a64f788f142df670c3abc809d32b6" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>try_lock</name></member>
      <member refid="group__cpp-rtos_1ga710a8b20e993bf1c74bf40f1ecce0a73" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>try_lock_for</name></member>
      <member refid="group__cpp-rtos_1ga41a3a30923d0f6c41a70812ef37db9bb" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>try_lock_until</name></member>
      <member refid="group__cpp-rtos_1ga9278be8203e1c42e2619179882ae4403" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>unlock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
