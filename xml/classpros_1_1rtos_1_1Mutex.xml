<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classpros_1_1rtos_1_1Mutex" kind="class" language="C++" prot="public">
    <compoundname>pros::rtos::Mutex</compoundname>
    <includes refid="rtos_8hpp" local="yes">rtos.hpp</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="group__cpp-rtos_1gabbacf876372ff9592f15777f84cb2663" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; std::remove_pointer_t&lt; <ref refid="group__c-rtos_1gab15ea84d90257d70b44e8e04519864d2" kindref="member">mutex_t</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt;std::remove_pointer_t&lt;mutex_t&gt; &gt; mutex</definition>
        <argsstring></argsstring>
        <name>mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="731" column="17" bodyfile="pros/rtos.hpp" bodystart="731" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="group__cpp-rtos_1ga4b5dfbd24f5bc4c03b24b2da362f66d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>()</argsstring>
        <name>Mutex</name>
        <briefdescription>
<para>Creates a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="multitasking" kindref="compound">Multitasking</ref> for details.</para>
<para><bold>Example</bold> <programlisting><codeline><highlight class="normal">Mutex<sp/>mutex;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Acquire<sp/>the<sp/>mutex;<sp/>other<sp/>tasks<sp/>using<sp/>this<sp/>command<sp/>will<sp/>wait<sp/>until<sp/>the<sp/>mutex<sp/>is<sp/>released</highlight></codeline>
<codeline><highlight class="normal">//<sp/>timeout<sp/>can<sp/>specify<sp/>the<sp/>maximum<sp/>time<sp/>to<sp/>wait,<sp/>or<sp/>MAX_DELAY<sp/>to<sp/>wait<sp/>forever</highlight></codeline>
<codeline><highlight class="normal">//<sp/>If<sp/>the<sp/>timeout<sp/>expires,<sp/>&quot;false&quot;<sp/>will<sp/>be<sp/>returned,<sp/>otherwise<sp/>&quot;true&quot;</highlight></codeline>
<codeline><highlight class="normal">mutex.take(MAX_DELAY);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>do<sp/>some<sp/>work</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Release<sp/>the<sp/>mutex<sp/>for<sp/>other<sp/>tasks</highlight></codeline>
<codeline><highlight class="normal">mutex.give();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="752" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gab09ea253b1dc6a2cf2543f9069af47f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>(const Mutex &amp;)=delete</argsstring>
        <name>Mutex</name>
        <param>
          <type>const <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="756" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gadd07188ea12392103ecbecf2215d603a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>(Mutex &amp;&amp;)=delete</argsstring>
        <name>Mutex</name>
        <param>
          <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="757" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaf883e9f2816275bfb96356ebab8343a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        <definition>Mutex&amp; operator=</definition>
        <argsstring>(const Mutex &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="759" column="7"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga346fc4a9a9db604140fb5e77e4ecf793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;</type>
        <definition>Mutex&amp; operator=</definition>
        <argsstring>(Mutex &amp;&amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="760" column="7"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga520dfb72e1768ce08292ca08662c66a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool take</definition>
        <argsstring>()</argsstring>
        <name>take</name>
        <briefdescription>
<para>Takes and locks a mutex indefinetly. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="multitasking" kindref="compound">Multitasking</ref> for details.</para>
<para><simplesect kind="return"><para>True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn&apos;t be taken.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">Mutex<sp/>mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Acquire<sp/>the<sp/>mutex;<sp/>does<sp/>not<sp/>time<sp/>out<sp/>if<sp/>parameter<sp/>not<sp/>specified.</highlight></codeline>
<codeline><highlight class="normal">mutex.take();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>do<sp/>some<sp/>work</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Release<sp/>the<sp/>mutex<sp/>for<sp/>other<sp/>tasks</highlight></codeline>
<codeline><highlight class="normal">mutex.give();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="782" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga4ed04a4dfdab9c125ecd5b87e1d31ac7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool take</definition>
        <argsstring>(std::uint32_t timeout)</argsstring>
        <name>take</name>
        <param>
          <type>std::uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting for up to a certain number of milliseconds before timing out. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="multitasking" kindref="compound">Multitasking</ref> for details.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the mutex becomes available. A timeout of 0 can be used to poll the mutex. TIMEOUT_MAX can be used to block indefinitely.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn&apos;t be taken.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">Mutex<sp/>mutex;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Acquire<sp/>the<sp/>mutex;<sp/>other<sp/>tasks<sp/>using<sp/>this<sp/>command<sp/>will<sp/>wait<sp/>until<sp/>the<sp/>mutex<sp/>is<sp/>released</highlight></codeline>
<codeline><highlight class="normal">//<sp/>timeout<sp/>can<sp/>specify<sp/>the<sp/>maximum<sp/>time<sp/>to<sp/>wait,<sp/>or<sp/>MAX_DELAY<sp/>to<sp/>wait<sp/>forever</highlight></codeline>
<codeline><highlight class="normal">//<sp/>If<sp/>the<sp/>timeout<sp/>expires,<sp/>&quot;false&quot;<sp/>will<sp/>be<sp/>returned,<sp/>otherwise<sp/>&quot;true&quot;</highlight></codeline>
<codeline><highlight class="normal">mutex.take(MAX_DELAY);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>do<sp/>some<sp/>work</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Release<sp/>the<sp/>mutex<sp/>for<sp/>other<sp/>tasks</highlight></codeline>
<codeline><highlight class="normal">mutex.give();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="811" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga89e3741a62333612b1a98074ec17c7bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool give</definition>
        <argsstring>()</argsstring>
        <name>give</name>
        <briefdescription>
<para>Unlocks a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="multitasking" kindref="compound">Multitasking</ref> for details.</para>
<para><simplesect kind="return"><para>True if the mutex was successfully returned, false otherwise. If false is returned, then errno is set with a hint about why the mutex couldn&apos;t be returned.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">Mutex<sp/>mutex;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Acquire<sp/>the<sp/>mutex;<sp/>other<sp/>tasks<sp/>using<sp/>this<sp/>command<sp/>will<sp/>wait<sp/>until<sp/>the<sp/>mutex<sp/>is<sp/>released</highlight></codeline>
<codeline><highlight class="normal">//<sp/>timeout<sp/>can<sp/>specify<sp/>the<sp/>maximum<sp/>time<sp/>to<sp/>wait,<sp/>or<sp/>MAX_DELAY<sp/>to<sp/>wait<sp/>forever</highlight></codeline>
<codeline><highlight class="normal">//<sp/>If<sp/>the<sp/>timeout<sp/>expires,<sp/>&quot;false&quot;<sp/>will<sp/>be<sp/>returned,<sp/>otherwise<sp/>&quot;true&quot;</highlight></codeline>
<codeline><highlight class="normal">mutex.take(MAX_DELAY);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>do<sp/>some<sp/>work</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Release<sp/>the<sp/>mutex<sp/>for<sp/>other<sp/>tasks</highlight></codeline>
<codeline><highlight class="normal">mutex.give();</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="834" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa81aed607133209dade63a226818224d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void lock</definition>
        <argsstring>()</argsstring>
        <name>lock</name>
        <briefdescription>
<para>Takes and locks a mutex, waiting for up to TIMEOUT_MAX milliseconds. </para>
        </briefdescription>
        <detaileddescription>
<para>Effectively equivalent to calling pros::Mutex::take with TIMEOUT_MAX as the parameter.</para>
<para>Conforms to named requirement <ulink url="https://en.cppreference.com/w/cpp/named_req/BasicLockable">BasicLockable</ulink></para>
<para><simplesect kind="note"><para>Consider using a std::unique_lock, std::lock_guard, or std::scoped_lock instead of interacting with the <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> directly.</para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::system_error</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> could not be locked within TIMEOUT_MAX milliseconds. see errno for details. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="850" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga9278be8203e1c42e2619179882ae4403" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void unlock</definition>
        <argsstring>()</argsstring>
        <name>unlock</name>
        <briefdescription>
<para>Unlocks a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to calling pros::Mutex::give.</para>
<para>Conforms to named requirement <ulink url="https://en.cppreference.com/w/cpp/named_req/BasicLockable">BasicLockable</ulink></para>
<para><simplesect kind="note"><para>Consider using a std::unique_lock, std::lock_guard, or std::scoped_lock instead of interacting with the <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> direcly. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="862" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa24a64f788f142df670c3abc809d32b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool try_lock</definition>
        <argsstring>()</argsstring>
        <name>try_lock</name>
        <briefdescription>
<para>Try to lock a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns immediately if unsucessful.</para>
<para>Conforms to named requirement <ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">TimedLockable</ulink></para>
<para><simplesect kind="return"><para>True when lock was acquired succesfully, or false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="873" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga710a8b20e993bf1c74bf40f1ecce0a73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Rep</type>
          </param>
          <param>
            <type>typename Period</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool try_lock_for</definition>
        <argsstring>(const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</argsstring>
        <name>try_lock_for</name>
        <param>
          <type>const std::chrono::duration&lt; Rep, Period &gt; &amp;</type>
          <declname>rel_time</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting for a specified duration. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to calling pros::Mutex::take with a duration specified in milliseconds.</para>
<para>Conforms to named requirement <ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">TimedLockable</ulink></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rel_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the mutex becomes available. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the lock was acquired succesfully, otherwise false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="887" column="6" bodyfile="pros/rtos.hpp" bodystart="887" bodyend="889"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga41a3a30923d0f6c41a70812ef37db9bb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Duration</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool try_lock_until</definition>
        <argsstring>(const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_time)</argsstring>
        <name>try_lock_until</name>
        <param>
          <type>const std::chrono::time_point&lt; <ref refid="structpros_1_1rtos_1_1Clock" kindref="compound">Clock</ref>, Duration &gt; &amp;</type>
          <declname>abs_time</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting until a specified time. </para>
        </briefdescription>
        <detaileddescription>
<para>Conforms to named requirement <ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">TimedLockable</ulink></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>abs_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point until which to wait for the mutex. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the lock was acquired succesfully, otherwise false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="900" column="6" bodyfile="pros/rtos.hpp" bodystart="900" bodyend="902"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="pros/rtos.hpp" line="726" column="12" bodyfile="pros/rtos.hpp" bodystart="726" bodyend="904"/>
    <listofallmembers>
      <member refid="group__cpp-rtos_1ga89e3741a62333612b1a98074ec17c7bc" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>give</name></member>
      <member refid="group__cpp-rtos_1gaa81aed607133209dade63a226818224d" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>lock</name></member>
      <member refid="group__cpp-rtos_1ga4b5dfbd24f5bc4c03b24b2da362f66d5" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>Mutex</name></member>
      <member refid="group__cpp-rtos_1gab09ea253b1dc6a2cf2543f9069af47f2" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>Mutex</name></member>
      <member refid="group__cpp-rtos_1gadd07188ea12392103ecbecf2215d603a" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>Mutex</name></member>
      <member refid="group__cpp-rtos_1gabbacf876372ff9592f15777f84cb2663" prot="private" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>mutex</name></member>
      <member refid="group__cpp-rtos_1gaf883e9f2816275bfb96356ebab8343a9" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>operator=</name></member>
      <member refid="group__cpp-rtos_1ga346fc4a9a9db604140fb5e77e4ecf793" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>operator=</name></member>
      <member refid="group__cpp-rtos_1ga520dfb72e1768ce08292ca08662c66a7" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>take</name></member>
      <member refid="group__cpp-rtos_1ga4ed04a4dfdab9c125ecd5b87e1d31ac7" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>take</name></member>
      <member refid="group__cpp-rtos_1gaa24a64f788f142df670c3abc809d32b6" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>try_lock</name></member>
      <member refid="group__cpp-rtos_1ga710a8b20e993bf1c74bf40f1ecce0a73" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>try_lock_for</name></member>
      <member refid="group__cpp-rtos_1ga41a3a30923d0f6c41a70812ef37db9bb" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>try_lock_until</name></member>
      <member refid="group__cpp-rtos_1ga9278be8203e1c42e2619179882ae4403" prot="public" virt="non-virtual"><scope>pros::rtos::Mutex</scope><name>unlock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
