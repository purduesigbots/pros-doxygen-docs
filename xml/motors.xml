<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="motors" kind="page">
    <compoundname>motors</compoundname>
    <title>Motors</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="note"><para>For a full list of functions for interacting with the V5 Motors, see its <ref refid="group__c-motors" kindref="compound">C API</ref> and <ref refid="group__cpp-motors" kindref="compound">C++ API</ref>.</para>
</simplesect>
</para>
<sect2 id="motors_1autotoc_md48">
<title>Initialization</title>
<para>V5 Motors should be configured before use in your code. Configuration options like the gearset and encoder units are important to address first thing in your user program to ensure that functions like <computeroutput><ref refid="group__c-motors_1ga2f3f7e0a243e9432b3d60e4b6147f177" kindref="member">motor_move_velocity()</ref></computeroutput> will work as expected.</para>
<para>When declaring motors in C++, it is not necessary to set the configuration for the motor with its constructor (beyond its port number) more than once for the given port. An example of this is given below.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#define<sp/>MOTOR_PORT<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="main_8h_1a1903abdb5ef0f301d660754c8315fc17" kindref="member">opcontrol</ref>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classpros_1_1Motor" kindref="compound">pros::Motor</ref><sp/>drive_left<sp/>(MOTOR_PORT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>drive_left<sp/>will<sp/>have<sp/>the<sp/>same<sp/>configuration<sp/>as<sp/>drive_left_initializer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="motors_1autotoc_md49">
<title>Simple Usage</title>
<para><ref refid="structThe" kindref="compound">The</ref> easiest way to interact with the motors is through the <ulink url="../../api/c/motors.html#motor-move">motor_move</ulink> function.</para>
</sect2>
<sect2 id="motors_1autotoc_md50">
<title>Autonomous Movement</title>
<para><ref refid="structThe" kindref="compound">The</ref> V5 Motors can move in a number of different ways that are better suited towards autonomous movement than the simple <computeroutput><ref refid="group__c-motors_1gac14bccd595a812fff8c30d2d050844a9" kindref="member">motor_move()</ref></computeroutput> example shown above.</para>
<sect3 id="motors_1autotoc_md51">
<title>Profile Movements</title>
<para>Profile movements are movements to a given position that are executed by the motor&apos;s firmware. There are two functions that achieve this, <computeroutput><ref refid="group__c-motors_1ga490a367ce2fea03acaa1e817c0648916" kindref="member">motor_move_absolute()</ref></computeroutput> and <computeroutput><ref refid="group__c-motors_1ga003028bf3f30c48559f442d7c0d74a9a" kindref="member">motor_move_relative()</ref></computeroutput>. These two functions are practically similar, but <computeroutput><ref refid="group__c-motors_1ga003028bf3f30c48559f442d7c0d74a9a" kindref="member">motor_move_relative()</ref></computeroutput> takes into account the zero position of the motor&apos;s encoder.</para>
<para>These functions are very well suited to movement in autonomous.</para>
<para>For further reading material on the algorithms that create these profiled movement, see <ulink url="https://pdfs.semanticscholar.org/a229/fdba63d8d68abd09f70604d56cc07ee50f7d.pdf">Mathematics of Motion Control Profiles</ulink> for the <ulink url="https://en.wikipedia.org/wiki/Feed_forward_(control)">Feedforward</ulink> control, and <ulink url="http://georgegillard.com/documents/2-introduction-to-pid-controllers">George Gillard&apos;s PID Explanation</ulink> for the <ulink url="https://en.wikipedia.org/wiki/Control_theory#PID_feedback_control">feedback</ulink> control.</para>
</sect3>
<sect3 id="motors_1autotoc_md52">
<title>Velocity Controller Movement</title>
<para><ref refid="structThe" kindref="compound">The</ref> final <computeroutput>move</computeroutput> function available with the PROS Motor API is <computeroutput><ref refid="group__c-motors_1ga2f3f7e0a243e9432b3d60e4b6147f177" kindref="member">motor_move_velocity()</ref></computeroutput>. <ref refid="structThis" kindref="compound">This</ref> ensures consistent velocity output from the motor through the use of <ulink url="http://georgegillard.com/documents/2-introduction-to-pid-controllers">PID</ulink>. </para>
</sect3>
</sect2>
    </detaileddescription>
  </compounddef>
</doxygen>
