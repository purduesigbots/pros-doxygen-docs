<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="group__cpp-rtos" kind="group">
    <compoundname>cpp-rtos</compoundname>
    <title>RTOS Facilities C++ API</title>
    <innerfile refid="rtos_8hpp">rtos.hpp</innerfile>
    <innerclass refid="classpros_1_1rtos_1_1Task" prot="public">pros::rtos::Task</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__cpp-rtos_1gadeb4da247e0f45e02e8ad0ff205445d7" prot="public" static="no">
        <type>std::uint32_t</type>
        <definition>using rep =  std::uint32_t</definition>
        <argsstring></argsstring>
        <name>rep</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="790" column="1" bodyfile="pros/rtos.hpp" bodystart="790" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__cpp-rtos_1gad6157965fe82b633df8345db024717f3" prot="public" static="no">
        <type>std::milli</type>
        <definition>using period =  std::milli</definition>
        <argsstring></argsstring>
        <name>period</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="791" column="1" bodyfile="pros/rtos.hpp" bodystart="791" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__cpp-rtos_1ga2b4de82f9ffc924d377f1392db0ba3ef" prot="public" static="no">
        <type>std::chrono::duration&lt; rep, period &gt;</type>
        <definition>using duration =  std::chrono::duration&lt;rep, period&gt;</definition>
        <argsstring></argsstring>
        <name>duration</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="792" column="1" bodyfile="pros/rtos.hpp" bodystart="792" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__cpp-rtos_1ga9076c3be2e8fb8b43e02a0f9552290e7" prot="public" static="no">
        <type>std::chrono::time_point&lt; Clock &gt;</type>
        <definition>using time_point =  std::chrono::time_point&lt;Clock&gt;</definition>
        <argsstring></argsstring>
        <name>time_point</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="793" column="1" bodyfile="pros/rtos.hpp" bodystart="793" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__cpp-rtos_1ga56cc089e11e076028d73369e1ba36e30" prot="private" static="no" mutable="no">
        <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
        <definition>task_t task</definition>
        <argsstring></argsstring>
        <name>task</name>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="785" column="8" bodyfile="pros/rtos.hpp" bodystart="785" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__cpp-rtos_1ga530b9e30754c9d0ef499b6cf1864317a" prot="public" static="no" mutable="no">
        <type>const bool</type>
        <definition>const bool is_steady</definition>
        <argsstring></argsstring>
        <name>is_steady</name>
        <initializer>= true</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="794" column="12" bodyfile="pros/rtos.hpp" bodystart="794" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__cpp-rtos_1gabbacf876372ff9592f15777f84cb2663" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; std::remove_pointer_t&lt; <ref refid="kapi_8h_1a93e65d556f878c762685fae603d1f95d" kindref="member">mutex_t</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt;std::remove_pointer_t&lt;mutex_t&gt; &gt; mutex</definition>
        <argsstring></argsstring>
        <name>mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="824" column="17" bodyfile="pros/rtos.hpp" bodystart="824" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__cpp-rtos_1gaf76b26c5282f35f6a25b9bd022c953cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Task</definition>
        <argsstring>(task_fn_t function, void *parameters=nullptr, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</argsstring>
        <name>Task</name>
        <param>
          <type><ref refid="kapi_8h_1afd273bc26dce33480b445457e89bfaeb" kindref="member">task_fn_t</ref></type>
          <declname>function</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>parameters</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>std::uint32_t</type>
          <declname>prio</declname>
          <defval><ref refid="group__c-rtos_1ga3082a7e8f15691441dba683711bb823f" kindref="member">TASK_PRIORITY_DEFAULT</ref></defval>
        </param>
        <param>
          <type>std::uint16_t</type>
          <declname>stack_depth</declname>
          <defval><ref refid="group__c-rtos_1ga9ffb33b9e3714ca949d9f45dde3cbf8f" kindref="member">TASK_STACK_DEPTH_DEFAULT</ref></defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Creates a new task and add it to the list of tasks that are ready to run. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the task entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parameters</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc&apos;d) or statically allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_depth</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of words (i.e. 4 * stack_depth) available on the task&apos;s stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>(void*)&quot;PROS&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="82" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga8d6642f2de80d6445619fe395568085d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Task</definition>
        <argsstring>(task_fn_t function, void *parameters, const char *name)</argsstring>
        <name>Task</name>
        <param>
          <type><ref refid="kapi_8h_1afd273bc26dce33480b445457e89bfaeb" kindref="member">task_fn_t</ref></type>
          <declname>function</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>parameters</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Creates a new task and add it to the list of tasks that are ready to run. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the task entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>parameters</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc&apos;d) or statically allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="115" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga1d372f751d498ee7dc15b08700b70547" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
        <definition>static task_t create</definition>
        <argsstring>(F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</argsstring>
        <name>create</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>function</declname>
        </param>
        <param>
          <type>std::uint32_t</type>
          <declname>prio</declname>
          <defval><ref refid="group__c-rtos_1ga3082a7e8f15691441dba683711bb823f" kindref="member">TASK_PRIORITY_DEFAULT</ref></defval>
        </param>
        <param>
          <type>std::uint16_t</type>
          <declname>stack_depth</declname>
          <defval><ref refid="group__c-rtos_1ga9ffb33b9e3714ca949d9f45dde3cbf8f" kindref="member">TASK_STACK_DEPTH_DEFAULT</ref></defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Creates a new task and add it to the list of tasks that are ready to run. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>Callable object to use as entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_depth</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of words (i.e. 4 * stack_depth) available on the task&apos;s stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::c::task_t<sp/>my_task<sp/>=<sp/>pros::Task::create(my_task_fn,<sp/>(void*)&quot;PROS&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="149" column="15" bodyfile="pros/rtos.hpp" bodystart="149" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga7eedd9988858633a57fd34b6059b07da" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
        <definition>static task_t create</definition>
        <argsstring>(F &amp;&amp;function, const char *name)</argsstring>
        <name>create</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>function</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Creates a new task and add it to the list of tasks that are ready to run. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>Callable object to use as entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::c::task_t<sp/>my_task<sp/>=<sp/>pros::Task::create(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="186" column="15" bodyfile="pros/rtos.hpp" bodystart="186" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa1ffe37a99acadd8b2b750e9a9f0bf14" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Task</definition>
        <argsstring>(F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</argsstring>
        <name>Task</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>function</declname>
        </param>
        <param>
          <type>std::uint32_t</type>
          <declname>prio</declname>
          <defval><ref refid="group__c-rtos_1ga3082a7e8f15691441dba683711bb823f" kindref="member">TASK_PRIORITY_DEFAULT</ref></defval>
        </param>
        <param>
          <type>std::uint16_t</type>
          <declname>stack_depth</declname>
          <defval><ref refid="group__c-rtos_1ga9ffb33b9e3714ca949d9f45dde3cbf8f" kindref="member">TASK_STACK_DEPTH_DEFAULT</ref></defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <briefdescription>
<para>Creates a new task and add it to the list of tasks that are ready to run. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>Callable object to use as entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_depth</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of words (i.e. 4 * stack_depth) available on the task&apos;s stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>a<sp/>task<sp/>function<sp/>using<sp/>lambdas</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>task_fn<sp/>=<sp/>[](void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="223" column="10" bodyfile="pros/rtos.hpp" bodystart="223" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gacbd0c9af4689e81baec06af05a16d29f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>Task</definition>
        <argsstring>(F &amp;&amp;function, const char *name)</argsstring>
        <name>Task</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>function</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Creates a new task and add it to the list of tasks that are ready to run. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>Callable object to use as entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[](void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Inside<sp/>the<sp/>task!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;My<sp/>Task&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="265" column="1" bodyfile="pros/rtos.hpp" bodystart="265" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga966220f76c100aa2fbfdb221d032ddd9" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>Task</definition>
        <argsstring>(task_t task)</argsstring>
        <name>Task</name>
        <param>
          <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>Create a C++ task object from a task handle. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>A task handle from <ref refid="group__c-rtos_1gab7f6e243b717091fec2bac6405bd3d56" kindref="member">task_create()</ref> for which to create a <ref refid="classpros_1_1rtos_1_1Task" kindref="compound">pros::Task</ref> object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::c::task_t<sp/>my_task<sp/>=<sp/>pros::Task::create(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task_cpp(my_task);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="289" column="10"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga6bc440ea23792294f5f41f00b3e4b5cd" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Task</type>
        <definition>static Task current</definition>
        <argsstring>()</argsstring>
        <name>current</name>
        <briefdescription>
<para>Get the currently running <ref refid="classpros_1_1rtos_1_1Task" kindref="compound">Task</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The currently running <ref refid="classpros_1_1rtos_1_1Task" kindref="compound">Task</ref>.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;The<sp/>name<sp/>of<sp/>this<sp/>task<sp/>is<sp/>\&quot;%s\&quot;\n&quot;,<sp/>pros::Task::current().get_name()</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>pros::TASK_PRIORITY_DEFAULT,<sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="307" column="13"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga6511e9f551c6e751f3b553f6235e3080" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Task &amp;</type>
        <definition>Task&amp; operator=</definition>
        <argsstring>(task_t in)</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
          <declname>in</declname>
        </param>
        <briefdescription>
<para>Creates a task object from the passed task handle. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>A task handle from <ref refid="group__c-rtos_1gab7f6e243b717091fec2bac6405bd3d56" kindref="member">task_create()</ref> for which to create a <ref refid="classpros_1_1rtos_1_1Task" kindref="compound">pros::Task</ref> object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;The<sp/>name<sp/>of<sp/>this<sp/>task<sp/>is<sp/>\&quot;%s\&quot;\n&quot;,<sp/>pros::Task::current().get_name()</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::c::task_t<sp/>my_task<sp/>=<sp/>pros::Task::create(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task_cpp<sp/>=<sp/>my_task;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="329" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga1fcb45e5d2428352eb36b487d1d4eea3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void remove</definition>
        <argsstring>()</argsstring>
        <name>remove</name>
        <briefdescription>
<para>Removes the <ref refid="classpros_1_1rtos_1_1Task" kindref="compound">Task</ref> from the RTOS real time kernel&apos;s management. </para>
        </briefdescription>
        <detaileddescription>
<para>This task will be removed from all ready, blocked, suspended and event lists.</para>
<para>Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted.</para>
<para><bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_task.remove();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="352" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga27921c9f94fc881b2a042320d8504731" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t get_priority</definition>
        <argsstring>()</argsstring>
        <name>get_priority</name>
        <briefdescription>
<para>Gets the priority of the specified task. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The priority of the task</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Task<sp/>Priority:<sp/>%d\n&quot;,<sp/>my_task.get_priority());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="373" column="15"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga685ad82d9352c7fe58deb1506ab6ab86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void set_priority</definition>
        <argsstring>(std::uint32_t prio)</argsstring>
        <name>set_priority</name>
        <param>
          <type>std::uint32_t</type>
          <declname>prio</declname>
        </param>
        <briefdescription>
<para>Sets the priority of the specified task. </para>
        </briefdescription>
        <detaileddescription>
<para>If the specified task&apos;s state is available to be scheduled (e.g. not blocked) and new priority is higher than the currently running task, a context switch may occur.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The new priority of the task</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Task.set_priority(pros::DEFAULT_PRIORITY<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="399" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga200ea249e657b61dd6a31fe60cbfe7e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t get_state</definition>
        <argsstring>()</argsstring>
        <name>get_state</name>
        <briefdescription>
<para>Gets the state of the specified task. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The state of the task</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Task<sp/>State:<sp/>%d\n&quot;,<sp/>my_task.get_state());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="420" column="15"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga3605b58fb45d69d498721bc2f2a14b1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void suspend</definition>
        <argsstring>()</argsstring>
        <name>suspend</name>
        <briefdescription>
<para>Suspends the specified task, making it ineligible to be scheduled. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Example</bold> <programlisting><codeline><highlight class="normal">pros::Mutex<sp/>counter_mutex;</highlight></codeline>
<codeline><highlight class="normal">int<sp/>counter<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>counter_mutex.take();<sp/>//<sp/>Mutexes<sp/>are<sp/>used<sp/>for<sp/>protecting<sp/>shared<sp/>resources</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pros::delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(counter<sp/>&gt;<sp/>100)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task_suspepend(task);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>counter_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pros::delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="453" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga41de8150eff044a237990c271d57ea27" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void resume</definition>
        <argsstring>()</argsstring>
        <name>resume</name>
        <briefdescription>
<para>Resumes the specified task, making it eligible to be scheduled. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>The task to resume</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>stuff</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pros::delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">pros::Task<sp/>task(my_task_fn);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>autonomous()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task.resume();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Run<sp/>autonomous<sp/>,<sp/>then<sp/>suspend<sp/>the<sp/>task<sp/>so<sp/>it<sp/>doesn&apos;t<sp/>interfere<sp/>run</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>outside<sp/>of<sp/>autonomous<sp/>or<sp/>opcontrol</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task.suspend();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task.resume();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Opctonrol<sp/>code<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task.suspend();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="488" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa37ab6a2f004bfa2c956115231072736" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* get_name</definition>
        <argsstring>()</argsstring>
        <name>get_name</name>
        <briefdescription>
<para>Gets the name of the specified task. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A pointer to the name of the task</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Number<sp/>of<sp/>Running<sp/>Tasks:<sp/>%d\n&quot;,<sp/>my_task.get_name());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="508" column="12"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaf68d7f3aeaf718187f2a74d80b1a669f" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>operator task_t</definition>
        <argsstring>()</argsstring>
        <name>operator task_t</name>
        <briefdescription>
<para>Convert this object to a C task_t handle. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn,<sp/>&quot;My<sp/>Task&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::c::task_t<sp/>my_task_c<sp/>=<sp/>(pros::c::task_t)my_task;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="527" column="10" bodyfile="pros/rtos.hpp" bodystart="527" bodyend="529"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga3673829895566e7151ddbb6cdca82d99" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t notify</definition>
        <argsstring>()</argsstring>
        <name>notify</name>
        <briefdescription>
<para>Sends a simple notification to task and increments the notification counter. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</ulink> for details.</para>
<para><simplesect kind="return"><para>Always returns true.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>ign)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(pros::Task::current_task().notify_take(true)<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Code<sp/>while<sp/>waiting</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>puts(&quot;I<sp/>was<sp/>unblocked!&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(controller_get_digital(CONTROLLER_MASTER,<sp/>DIGITAL_L1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>my_task.notify();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="560" column="15"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga6c7abfff648dad193674fc432ad4840d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void join</definition>
        <argsstring>()</argsstring>
        <name>join</name>
        <briefdescription>
<para>Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program. </para>
        </briefdescription>
        <detaileddescription>
<para>Analogous to std::thread::join in C++.</para>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</ulink> for details.</para>
<para><simplesect kind="return"><para>void</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>ign)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcd_print(1,<sp/>&quot;%s<sp/>running&quot;,<sp/>pros::Task::current_task().get_name());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lcd_print(2,<sp/>&quot;End<sp/>of<sp/>%s&quot;,<sp/>pros::Task::current_task().get_name());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::lcd::set_text(0,<sp/>&quot;Running<sp/>task.&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_task.join();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::lcd::lcd_set_text(3,<sp/>&quot;Task<sp/>completed.&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="587" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga8416442a23f42ca38044c9b2dec99316" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t notify_ext</definition>
        <argsstring>(std::uint32_t value, notify_action_e_t action, std::uint32_t *prev_value)</argsstring>
        <name>notify_ext</name>
        <param>
          <type>std::uint32_t</type>
          <declname>value</declname>
        </param>
        <param>
          <type>notify_action_e_t</type>
          <declname>action</declname>
        </param>
        <param>
          <type>std::uint32_t *</type>
          <declname>prev_value</declname>
        </param>
        <briefdescription>
<para>Sends a notification to a task, optionally performing some action. </para>
        </briefdescription>
        <detaileddescription>
<para>Will also retrieve the value of the notification in the target task before modifying the notification value.</para>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</ulink> for details.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value used in performing the action </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>An action to optionally perform on the receiving task&apos;s notification value </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prev_value</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to store the previous value of the target task&apos;s notification, may be NULL</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Dependent on the notification action. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise. For all other NOTIFY_ACTION values: always return 0</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task<sp/>=<sp/>pros::Task::current();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Wait<sp/>until<sp/>we<sp/>have<sp/>been<sp/>notified<sp/>20<sp/>times<sp/>before<sp/>running<sp/>the<sp/>code</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(task.notify_take(false,<sp/>TIMEOUT_MAX)<sp/>==<sp/>20)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>...<sp/>Code<sp/>to<sp/>do<sp/>stuff<sp/>here<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Reset<sp/>the<sp/>notification<sp/>counter</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task.notify_clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task(my_task_fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(controller_get_digital(CONTROLLER_MASTER,<sp/>DIGITAL_L1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task.notify_ext(1,<sp/>NOTIFY_ACTION_INCREMENT,<sp/>&amp;count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(20);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="643" column="15"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga070827d25e8a07d2124578dcbd638dd0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>static std::uint32_t notify_take</definition>
        <argsstring>(bool clear_on_exit, std::uint32_t timeout)</argsstring>
        <name>notify_take</name>
        <param>
          <type>bool</type>
          <declname>clear_on_exit</declname>
        </param>
        <param>
          <type>std::uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Waits for a notification to be nonzero. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</ulink> for details.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>clear_on_exit</parametername>
</parameternamelist>
<parameterdescription>
<para>If true (1), then the notification value is cleared. If false (0), then the notification value is decremented. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the amount of time to be spent waiting for a notification to occur.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value of the task&apos;s notification value before it is decremented or cleared</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>ign)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task<sp/>=<sp/>pros::task::current();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(task.notify_take(true,<sp/>TIMEOUT_MAX))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>puts(&quot;I<sp/>was<sp/>unblocked!&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task(my_task_fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(controller_get_digital(CONTROLLER_MASTER,<sp/>DIGITAL_L1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task.notify(my_task);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="680" column="22"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga6b470af6702dc8031d6de86419c97b54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool notify_clear</definition>
        <argsstring>()</argsstring>
        <name>notify_clear</name>
        <briefdescription>
<para>Clears the notification for a task. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</ulink> for details.</para>
<para><simplesect kind="return"><para>False if there was not a notification waiting, true if there was <bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task<sp/>=<sp/>pros::Task::current();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Waiting<sp/>for<sp/>notification...\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Got<sp/>a<sp/>notification:<sp/>%d\n&quot;,<sp/>task.notify_take(false,<sp/>TIMEOUT_MAX));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tasK_notify(task);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>task(my_task_fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(controller_get_digital(CONTROLLER_MASTER,<sp/>DIGITAL_L1))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task.notify();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="713" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gafd19e4a13c12c607998bcfc56768ddbc" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void delay</definition>
        <argsstring>(const std::uint32_t milliseconds)</argsstring>
        <name>delay</name>
        <param>
          <type>const std::uint32_t</type>
          <declname>milliseconds</declname>
        </param>
        <briefdescription>
<para>Delays the current task for a specified number of milliseconds. </para>
        </briefdescription>
        <detaileddescription>
<para>This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use <ref refid="group__c-rtos_1ga151eaf730a10d101bff15013a76b9aa8" kindref="member">task_delay_until()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>milliseconds</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of milliseconds to wait (1000 milliseconds per second)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>opcontrol<sp/>things</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pros::Task::delay(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="734" column="13"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gafcfc4faff77d7ca1f4c080d1e8c508fa" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void delay_until</definition>
        <argsstring>(std::uint32_t *const prev_time, const std::uint32_t delta)</argsstring>
        <name>delay_until</name>
        <param>
          <type>std::uint32_t *const</type>
          <declname>prev_time</declname>
        </param>
        <param>
          <type>const std::uint32_t</type>
          <declname>delta</declname>
        </param>
        <briefdescription>
<para>Delays the current <ref refid="classpros_1_1rtos_1_1Task" kindref="compound">Task</ref> until a specified time. </para>
        </briefdescription>
        <detaileddescription>
<para>This function can be used by periodic tasks to ensure a constant execution frequency.</para>
<para>The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>prev_time</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to the location storing the setpoint time. This should typically be initialized to the return value from <ref refid="group__c-rtos_1gaa247cd38039665b7ac4b0d0920b83c80" kindref="member">pros::millis()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of milliseconds to wait (1000 milliseconds per second)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>opcontrol<sp/>things</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pros::Task::delay(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="759" column="13"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gac7509321b5f36585f28da108d330b9ad" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>static std::uint32_t get_count</definition>
        <argsstring>()</argsstring>
        <name>get_count</name>
        <briefdescription>
<para>Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks. </para>
        </briefdescription>
        <detaileddescription>
<para>A task that has been deleted, but not yet reaped by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.</para>
<para><simplesect kind="return"><para>The number of tasks that are currently being managed by the kernel.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Hello<sp/>%s\n&quot;,<sp/>(char*)param);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>my_task(my_task_fn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;There<sp/>are<sp/>%d<sp/>tasks<sp/>running\n&quot;,<sp/>pros::Task::get_count());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="782" column="22"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga1e90d26a2b528a402135160280637dbc" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>time_point</type>
        <definition>static time_point now</definition>
        <argsstring>()</argsstring>
        <name>now</name>
        <briefdescription>
<para>Gets the current time. </para>
        </briefdescription>
        <detaileddescription>
<para>Effectively a wrapper around <ref refid="group__c-rtos_1gaa247cd38039665b7ac4b0d0920b83c80" kindref="member">pros::millis()</ref></para>
<para><simplesect kind="return"><para>The current time</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Clock::time_point<sp/>start<sp/>=<sp/>pros::Clock::now();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Clock::time_point<sp/>end<sp/>=<sp/>pros::Clock::now();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Clock::duration<sp/>duration<sp/>=<sp/>end<sp/>-<sp/>start;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Duration:<sp/>%d\n&quot;,<sp/>duration.count());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if(duration.count()<sp/>==<sp/>500)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>you<sp/>see<sp/>this<sp/>comment<sp/>in<sp/>the<sp/>DOCS,<sp/>ping<sp/>@pros<sp/>in<sp/>VTOW.<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>If<sp/>you<sp/>are<sp/>the<sp/>first<sp/>person<sp/>to<sp/>do<sp/>so,<sp/>you<sp/>will<sp/>receive<sp/>a<sp/>free<sp/>PROS<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>holo!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Duration<sp/>is<sp/>500<sp/>milliseconds\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="820" column="19"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga4b5dfbd24f5bc4c03b24b2da362f66d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>()</argsstring>
        <name>Mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="827" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gab09ea253b1dc6a2cf2543f9069af47f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>(const Mutex &amp;)=delete</argsstring>
        <name>Mutex</name>
        <param>
          <type>const Mutex &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="831" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gadd07188ea12392103ecbecf2215d603a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Mutex</definition>
        <argsstring>(Mutex &amp;&amp;)=delete</argsstring>
        <name>Mutex</name>
        <param>
          <type>Mutex &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="832" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaf883e9f2816275bfb96356ebab8343a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Mutex &amp;</type>
        <definition>Mutex&amp; operator=</definition>
        <argsstring>(const Mutex &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const Mutex &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="834" column="7"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga346fc4a9a9db604140fb5e77e4ecf793" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Mutex &amp;</type>
        <definition>Mutex&amp; operator=</definition>
        <argsstring>(Mutex &amp;&amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>Mutex &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="835" column="7"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga520dfb72e1768ce08292ca08662c66a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool take</definition>
        <argsstring>()</argsstring>
        <name>take</name>
        <briefdescription>
<para>Takes and locks a mutex indefinetly. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes">https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes</ulink> for details.</para>
<para><simplesect kind="return"><para>True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn&apos;t be taken</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="917" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga4ed04a4dfdab9c125ecd5b87e1d31ac7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool take</definition>
        <argsstring>(std::uint32_t timeout)</argsstring>
        <name>take</name>
        <param>
          <type>std::uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting for up to a certain number of milliseconds before timing out. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes">https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes</ulink> for details.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the mutex becomes available. A timeout of 0 can be used to poll the mutex. TIMEOUT_MAX can be used to block indefinitely.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the mutex was successfully taken, false otherwise. If false is returned, then errno is set with a hint about why the the mutex couldn&apos;t be taken.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1005" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga89e3741a62333612b1a98074ec17c7bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool give</definition>
        <argsstring>()</argsstring>
        <name>give</name>
        <briefdescription>
<para>Unlocks a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ulink url="https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes">https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes</ulink> for details.</para>
<para><simplesect kind="return"><para>True if the mutex was successfully returned, false otherwise. If false is returned, then errno is set with a hint about why the mutex couldn&apos;t be returned.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.take();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.give();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1087" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa81aed607133209dade63a226818224d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void lock</definition>
        <argsstring>()</argsstring>
        <name>lock</name>
        <briefdescription>
<para>Takes and locks a mutex, waiting for up to TIMEOUT_MAX milliseconds. </para>
        </briefdescription>
        <detaileddescription>
<para>Effectively equivalent to calling pros::Mutex::take with TIMEOUT_MAX as the parameter.</para>
<para>Conforms to named requirment BasicLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/BasicLockable">https://en.cppreference.com/w/cpp/named_req/BasicLockable</ulink></para>
</simplesect>
<simplesect kind="note"><para>Consider using a std::unique_lock, std::lock_guard, or std::scoped_lock instead of interacting with the <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> directly.</para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::system_error</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> could not be locked within TIMEOUT_MAX milliseconds. see errno for details.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1173" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga9278be8203e1c42e2619179882ae4403" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void unlock</definition>
        <argsstring>()</argsstring>
        <name>unlock</name>
        <briefdescription>
<para>Unlocks a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to calling pros::Mutex::give.</para>
<para>Conforms to named requirement BasicLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/BasicLockable">https://en.cppreference.com/w/cpp/named_req/BasicLockable</ulink></para>
</simplesect>
<simplesect kind="note"><para>Consider using a std::unique_lock, std::lock_guard, or std::scoped_lock instead of interacting with the <ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">Mutex</ref> direcly.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">//<sp/>Global<sp/>variables<sp/>for<sp/>the<sp/>robot&apos;s<sp/>odometry,<sp/>which<sp/>the<sp/>rest<sp/>of<sp/>the<sp/>robot&apos;s</highlight></codeline>
<codeline><highlight class="normal">//<sp/>subsystems<sp/>will<sp/>utilize</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_x<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_y<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>odom_heading<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>mutex<sp/>protects<sp/>the<sp/>odometry<sp/>data.<sp/>Whenever<sp/>we<sp/>read<sp/>or<sp/>write<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>odometry<sp/>data,<sp/>we<sp/>should<sp/>make<sp/>copies<sp/>into<sp/>the<sp/>local<sp/>variables,<sp/>and<sp/>read</highlight></codeline>
<codeline><highlight class="normal">//<sp/>all<sp/>3<sp/>values<sp/>at<sp/>once<sp/>to<sp/>avoid<sp/>errors.</highlight></codeline>
<codeline><highlight class="normal">pros::Mutex<sp/>odom_mutex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>odom_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>First<sp/>we<sp/>fetch<sp/>the<sp/>odom<sp/>coordinates<sp/>from<sp/>the<sp/>previous<sp/>iteration<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>odometry<sp/>task.<sp/>These<sp/>are<sp/>put<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that<sp/>we<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>keep<sp/>the<sp/>size<sp/>of<sp/>the<sp/>critical<sp/>section<sp/>as<sp/>small<sp/>as<sp/>possible.<sp/>This<sp/>lets</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>tasks<sp/>that<sp/>need<sp/>to<sp/>use<sp/>the<sp/>odometry<sp/>data<sp/>run<sp/>until<sp/>we<sp/>need<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>update<sp/>it<sp/>again.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_old<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_old<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_old<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>x_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>y_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>heading_new<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>---<sp/>Calculate<sp/>new<sp/>pose<sp/>for<sp/>the<sp/>robot<sp/>here<sp/>---</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Now<sp/>that<sp/>we<sp/>have<sp/>the<sp/>new<sp/>pose,<sp/>we<sp/>can<sp/>update<sp/>the<sp/>global<sp/>variables</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_x<sp/>=<sp/>x_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_y<sp/>=<sp/>y_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_heading<sp/>=<sp/>heading_new;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>chassis_task(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Here<sp/>we<sp/>copy<sp/>the<sp/>current<sp/>odom<sp/>values<sp/>into<sp/>local<sp/>variables<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>we<sp/>can<sp/>use<sp/>them<sp/>without<sp/>worrying<sp/>about<sp/>the<sp/>odometry<sp/>task<sp/>changing<sp/>say,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>y<sp/>value<sp/>right<sp/>after<sp/>we&apos;ve<sp/>read<sp/>the<sp/>x.<sp/>This<sp/>ensures<sp/>our<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>sound.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.lock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_x<sp/>=<sp/>odom_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_y<sp/>=<sp/>odom_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>current_heading<sp/>=<sp/>odom_heading;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>odom_mutex.unlock();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>----<sp/>Move<sp/>the<sp/>robot<sp/>using<sp/>the<sp/>current<sp/>locations<sp/>goes<sp/>here<sp/>----</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>delay(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>odom_mutex<sp/>=<sp/>pros::Mutex();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>odom_task(odom_task,<sp/>&quot;Odometry<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pros::Task<sp/>chassis_task(odom_task,<sp/>&quot;Chassis<sp/>Control<sp/>Task&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1255" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1gaa24a64f788f142df670c3abc809d32b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool try_lock</definition>
        <argsstring>()</argsstring>
        <name>try_lock</name>
        <briefdescription>
<para>Try to lock a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns immediately if unsucessful.</para>
<para>Conforms to named requirement Lockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/Lockable">https://en.cppreference.com/w/cpp/named_req/Lockable</ulink></para>
</simplesect>
<simplesect kind="return"><para>True when lock was acquired succesfully, or false otherwise.</para>
</simplesect>
<ref refid="classpros_1_1rtos_1_1Mutex" kindref="compound">pros::Mutex</ref> mutex;</para>
<para>void my_task_fn(void* param) { while (true) { if(mutex.try_lock()) { printf(&quot;Mutex aquired successfully!\n&quot;); // Do stuff that requires the protected resource here } else { printf(&quot;Mutex not aquired!\n&quot;); } } } </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1281" column="6"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga710a8b20e993bf1c74bf40f1ecce0a73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Rep</type>
          </param>
          <param>
            <type>typename Period</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool try_lock_for</definition>
        <argsstring>(const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</argsstring>
        <name>try_lock_for</name>
        <param>
          <type>const std::chrono::duration&lt; Rep, Period &gt; &amp;</type>
          <declname>rel_time</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting for a specified duration. </para>
        </briefdescription>
        <detaileddescription>
<para>Equivalent to calling pros::Mutex::take with a duration specified in milliseconds.</para>
<para>Conforms to named requirement TimedLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">https://en.cppreference.com/w/cpp/named_req/TimedLockable</ulink></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rel_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the mutex becomes available. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the lock was acquired succesfully, otherwise false.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(mutex.try_lock_for(std::chrono::milliseconds(100)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>aquired<sp/>successfully!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>stuff<sp/>that<sp/>requires<sp/>the<sp/>protected<sp/>resource<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>not<sp/>aquired<sp/>after<sp/>100<sp/>milliseconds!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1311" column="6" bodyfile="pros/rtos.hpp" bodystart="1311" bodyend="1313"/>
      </memberdef>
      <memberdef kind="function" id="group__cpp-rtos_1ga41a3a30923d0f6c41a70812ef37db9bb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Duration</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool try_lock_until</definition>
        <argsstring>(const std::chrono::time_point&lt; Clock, Duration &gt; &amp;abs_time)</argsstring>
        <name>try_lock_until</name>
        <param>
          <type>const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</type>
          <declname>abs_time</declname>
        </param>
        <briefdescription>
<para>Takes and locks a mutex, waiting until a specified time. </para>
        </briefdescription>
        <detaileddescription>
<para>Conforms to named requirement TimedLockable <simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/named_req/TimedLockable">https://en.cppreference.com/w/cpp/named_req/TimedLockable</ulink></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>abs_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point until which to wait for the mutex. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the lock was acquired succesfully, otherwise false.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>my_task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(true)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>the<sp/>current<sp/>time<sp/>point</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>auto<sp/>now<sp/>=<sp/>std::chrono::system_clock::now();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Calculate<sp/>the<sp/>time<sp/>point<sp/>100<sp/>milliseconds<sp/>from<sp/>now</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>auto<sp/>abs_time<sp/>=<sp/>now<sp/>+<sp/>std::chrono::milliseconds(100);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(mutex.try_lock_until(abs_time))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>aquired<sp/>successfully!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Do<sp/>stuff<sp/>that<sp/>requires<sp/>the<sp/>protected<sp/>resource<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>not<sp/>aquired<sp/>after<sp/>100<sp/>milliseconds!\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/rtos.hpp" line="1346" column="6" bodyfile="pros/rtos.hpp" bodystart="1346" bodyend="1348"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="note"><para>Additional example code for this module can be found in its <ref refid="multitasking" kindref="compound">Tutorial.</ref> </para>
</simplesect>
</para>
    </detaileddescription>
  </compounddef>
</doxygen>
