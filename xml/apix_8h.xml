<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="apix_8h" kind="file" language="C++">
    <compoundname>apix.h</compoundname>
    <includes refid="api_8h" local="yes">api.h</includes>
    <includes refid="device_8h" local="yes">pros/device.h</includes>
    <includes refid="serial_8h" local="yes">pros/serial.h</includes>
    <includes refid="serial_8hpp" local="yes">pros/serial.hpp</includes>
    <includedby refid="kapi_8h" local="yes">kapi.h</includedby>
    <incdepgraph>
      <node id="12">
        <label>stdbool.h</label>
      </node>
      <node id="41">
        <label>pros/rtos.hpp</label>
        <link refid="rtos_8hpp"/>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="30">
        <label>stdarg.h</label>
      </node>
      <node id="29">
        <label>pros/screen.h</label>
        <link refid="screen_8h"/>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>functional</label>
      </node>
      <node id="33">
        <label>pros/adi.hpp</label>
        <link refid="adi_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="51">
        <label>pros/llemu.hpp</label>
        <link refid="pros_2include_2pros_2llemu_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
      </node>
      <node id="24">
        <label>pros/misc.h</label>
        <link refid="misc_8h"/>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>cstdint</label>
      </node>
      <node id="37">
        <label>pros/colors.hpp</label>
        <link refid="colors_8hpp"/>
      </node>
      <node id="27">
        <label>pros/rotation.h</label>
        <link refid="rotation_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>stdint.h</label>
      </node>
      <node id="47">
        <label>pros/distance.hpp</label>
        <link refid="distance_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>cstdbool</label>
      </node>
      <node id="4">
        <label>cmath</label>
      </node>
      <node id="57">
        <label>pros/screen.hpp</label>
        <link refid="screen_8hpp"/>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>string</label>
      </node>
      <node id="1">
        <label>pros/apix.h</label>
        <link refid="apix_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="59" relation="include">
        </childnode>
        <childnode refid="60" relation="include">
        </childnode>
      </node>
      <node id="48">
        <label>pros/gps.hpp</label>
        <link refid="gps_8hpp"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="21">
        <label>pros/imu.h</label>
        <link refid="imu_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>limits.h</label>
      </node>
      <node id="50">
        <label>pros/link.hpp</label>
        <link refid="link_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="23">
        <label>pros/llemu.h</label>
        <link refid="pros_2include_2pros_2llemu_8h"/>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="60">
        <label>pros/serial.hpp</label>
        <link refid="serial_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="59" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>cstdio</label>
      </node>
      <node id="35">
        <label>tuple</label>
      </node>
      <node id="45">
        <label>optional</label>
      </node>
      <node id="22">
        <label>pros/link.h</label>
        <link refid="link_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="17">
        <label>pros/error.h</label>
        <link refid="error_8h"/>
        <childnode refid="18" relation="include">
        </childnode>
      </node>
      <node id="55">
        <label>pros/optical.hpp</label>
        <link refid="optical_8hpp"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>vector</label>
      </node>
      <node id="56">
        <label>pros/rotation.hpp</label>
        <link refid="rotation_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>pros/adi.h</label>
        <link refid="adi_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="36">
        <label>utility</label>
      </node>
      <node id="2">
        <label>api.h</label>
        <link refid="api_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="47" relation="include">
        </childnode>
        <childnode refid="48" relation="include">
        </childnode>
        <childnode refid="49" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
        <childnode refid="51" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="52" relation="include">
        </childnode>
        <childnode refid="54" relation="include">
        </childnode>
        <childnode refid="55" relation="include">
        </childnode>
        <childnode refid="56" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="57" relation="include">
        </childnode>
        <childnode refid="58" relation="include">
        </childnode>
      </node>
      <node id="20">
        <label>pros/gps.h</label>
        <link refid="gps_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="52">
        <label>pros/motor_group.hpp</label>
        <link refid="motor__group_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="53" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="54" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="54">
        <label>pros/motors.hpp</label>
        <link refid="motors_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="53" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>cerrno</label>
      </node>
      <node id="9">
        <label>cstdlib</label>
      </node>
      <node id="10">
        <label>iostream</label>
      </node>
      <node id="6">
        <label>cstddef</label>
      </node>
      <node id="32">
        <label>pros/vision.h</label>
        <link refid="vision_8h"/>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>pros/device.h</label>
        <link refid="device_8h"/>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="25">
        <label>pros/motors.h</label>
        <link refid="motors_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="58">
        <label>pros/vision.hpp</label>
        <link refid="vision_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>chrono</label>
      </node>
      <node id="59">
        <label>pros/serial.h</label>
        <link refid="serial_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>pros/colors.h</label>
        <link refid="colors_8h"/>
      </node>
      <node id="53">
        <label>pros/abstract_motor.hpp</label>
        <link refid="abstract__motor_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="49">
        <label>pros/imu.hpp</label>
        <link refid="imu_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="26">
        <label>pros/optical.h</label>
        <link refid="optical_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
      </node>
      <node id="16">
        <label>pros/distance.h</label>
        <link refid="distance_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="28">
        <label>pros/rtos.h</label>
        <link refid="rtos_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="46">
        <label>type_traits</label>
      </node>
      <node id="38">
        <label>pros/device.hpp</label>
        <link refid="device_8hpp"/>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>pros/misc.hpp</label>
        <link refid="misc_8hpp"/>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
      </node>
      <node id="31">
        <label>stdio.h</label>
      </node>
      <node id="19">
        <label>pros/ext_adi.h</label>
        <link refid="ext__adi_8h"/>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>memory</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="2">
        <label>kapi.h</label>
        <link refid="kapi_8h"/>
      </node>
      <node id="1">
        <label>pros/apix.h</label>
        <link refid="apix_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <innernamespace refid="namespacepros">pros</innernamespace>
    <innernamespace refid="namespacepros_1_1c">pros::c</innernamespace>
      <sectiondef kind="user-defined">
      <header>RTOS Facilities</header>
      <memberdef kind="typedef" id="group__apix_1ga2d363eefb03348f96e985eadcfb184ab" prot="public" static="no">
        <type>void *</type>
        <definition>typedef void* queue_t</definition>
        <argsstring></argsstring>
        <name>queue_t</name>
        <briefdescription>
<para>Unblocks a task in the Blocked state (e.g. </para>
        </briefdescription>
        <detaileddescription>
<para>waiting for a delay, on a semaphore, etc.).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>The task to unblock</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the task was unblocked, false otherwise</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">task_t<sp/>task<sp/>=<sp/>task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline><highlight class="normal">task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>in<sp/>another<sp/>task<sp/>somewhere<sp/>else,<sp/>this<sp/>will<sp/>abort<sp/>the<sp/>task_delay<sp/>bove:</highlight></codeline>
<codeline><highlight class="normal">task_abort_delay(task);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="53" column="14" bodyfile="pros/apix.h" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__apix_1gabc53a59ab4c3c8f2d7660e63990be7a7" prot="public" static="no">
        <type>void *</type>
        <definition>typedef void* sem_t</definition>
        <argsstring></argsstring>
        <name>sem_t</name>
        <briefdescription>
<para>Unblocks a task in the Blocked state (e.g. </para>
        </briefdescription>
        <detaileddescription>
<para>waiting for a delay, on a semaphore, etc.).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>The task to unblock</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the task was unblocked, false otherwise</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">task_t<sp/>task<sp/>=<sp/>task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline><highlight class="normal">task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>in<sp/>another<sp/>task<sp/>somewhere<sp/>else,<sp/>this<sp/>will<sp/>abort<sp/>the<sp/>task_delay<sp/>bove:</highlight></codeline>
<codeline><highlight class="normal">task_abort_delay(task);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="54" column="14" bodyfile="pros/apix.h" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gaeace1284e382f9a8cd7734a34965770a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::task_abort_delay</definition>
        <argsstring>(task_t task)</argsstring>
        <name>task_abort_delay</name>
        <param>
          <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>Unblocks a task in the Blocked state (e.g. </para>
        </briefdescription>
        <detaileddescription>
<para>waiting for a delay, on a semaphore, etc.).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>The task to unblock</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the task was unblocked, false otherwise</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">task_t<sp/>task<sp/>=<sp/>task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline><highlight class="normal">task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>in<sp/>another<sp/>task<sp/>somewhere<sp/>else,<sp/>this<sp/>will<sp/>abort<sp/>the<sp/>task_delay<sp/>bove:</highlight></codeline>
<codeline><highlight class="normal">task_abort_delay(task);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="74" column="6" declfile="pros/apix.h" declline="74" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga8e451f518ac641b2aba0dad90ba12a28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void pros::c::task_notify_when_deleting</definition>
        <argsstring>(task_t target_task, task_t task_to_notify, uint32_t value, notify_action_e_t notify_action)</argsstring>
        <name>task_notify_when_deleting</name>
        <param>
          <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
          <declname>target_task</declname>
        </param>
        <param>
          <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
          <declname>task_to_notify</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>value</declname>
        </param>
        <param>
          <type>notify_action_e_t</type>
          <declname>notify_action</declname>
        </param>
        <briefdescription>
<para>Notify a task when a target task is being deleted. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>target_task</parametername>
</parameternamelist>
<parameterdescription>
<para>The task being watched for deletion </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>task_to_notify</parametername>
</parameternamelist>
<parameterdescription>
<para>The task to notify when target_task is deleted </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to supply to task_notify_ext </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>notify_action</parametername>
</parameternamelist>
<parameterdescription>
<para>The action to supply to task_notify_ext</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">task_t<sp/>task_to_delete<sp/>=<sp/>task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline><highlight class="normal">task_t<sp/>task_to_notify<sp/>=<sp/>task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn2&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">task_notify_ext(task_to_notify,<sp/>0,<sp/>NOTIFY_ACTION_INCREMENT,<sp/>NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">task_notify_when_deleting(task_to_delete,<sp/>task_get_current(),<sp/>0,<sp/>NOTIFY_ACTION_NONE);</highlight></codeline>
<codeline><highlight class="normal">task_delete(task_to_delete);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="101" column="6" declfile="pros/apix.h" declline="101" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga4eef1a2598a22cbf8000fe03633d0b13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="kapi_8h_1a93e65d556f878c762685fae603d1f95d" kindref="member">mutex_t</ref></type>
        <definition>mutex_t pros::c::mutex_recursive_create</definition>
        <argsstring>(void)</argsstring>
        <name>mutex_recursive_create</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Creates a recursive mutex which can be locked recursively by the owner. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A newly created recursive mutex.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">mutex_t<sp/>mutex<sp/>=<sp/>mutex_recursive_create();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mutex_recursive_take(mutex,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mutex_recursive_give(mutex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="126" column="9" declfile="pros/apix.h" declline="126" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga960dac0c60f0f13331f14325d56d7506" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::mutex_recursive_take</definition>
        <argsstring>(mutex_t mutex, uint32_t timeout)</argsstring>
        <name>mutex_recursive_take</name>
        <param>
          <type><ref refid="kapi_8h_1a93e65d556f878c762685fae603d1f95d" kindref="member">mutex_t</ref></type>
          <declname>mutex</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Takes a recursive mutex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mutex</parametername>
</parameternamelist>
<parameterdescription>
<para>A mutex handle created by mutex_recursive_create </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wait_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Amount of time to wait before timing out</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the mutex was obtained, 0 otherwise</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">mutex_t<sp/>mutex<sp/>=<sp/>mutex_recursive_create();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mutex_recursive_take(mutex,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mutex_recursive_give(mutex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="155" column="6" declfile="pros/apix.h" declline="155" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga0366fbae5b45a13bb3d76ba963fde37b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::mutex_recursive_give</definition>
        <argsstring>(mutex_t mutex)</argsstring>
        <name>mutex_recursive_give</name>
        <param>
          <type><ref refid="kapi_8h_1a93e65d556f878c762685fae603d1f95d" kindref="member">mutex_t</ref></type>
          <declname>mutex</declname>
        </param>
        <briefdescription>
<para>Gives a recursive mutex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mutex</parametername>
</parameternamelist>
<parameterdescription>
<para>A mutex handle created by mutex_recursive_create</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the mutex was obtained, 0 otherwise</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">mutex_t<sp/>mutex<sp/>=<sp/>mutex_recursive_create();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mutex_recursive_take(mutex,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mutex_recursive_give(mutex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="182" column="6" declfile="pros/apix.h" declline="182" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga35e2514c392ad052f702c7c6a3ed5ae2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="kapi_8h_1af4e78a5aaf6b45938ea1d203bbc5ad12" kindref="member">task_t</ref></type>
        <definition>task_t pros::c::mutex_get_owner</definition>
        <argsstring>(mutex_t mutex)</argsstring>
        <name>mutex_get_owner</name>
        <param>
          <type><ref refid="kapi_8h_1a93e65d556f878c762685fae603d1f95d" kindref="member">mutex_t</ref></type>
          <declname>mutex</declname>
        </param>
        <briefdescription>
<para>Returns a handle to the current owner of a mutex. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mutex</parametername>
</parameternamelist>
<parameterdescription>
<para>A mutex handle</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A handle to the current task that owns the mutex, or NULL if the mutex isn&apos;t owned.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal"><sp/>mutex_t<sp/>mutex<sp/>=<sp/>mutex_create();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>mutex_take(mutex,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>mutex_give(mutex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(joystick_get_digital(1,<sp/>7,<sp/>JOY_UP))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task_t<sp/>owner<sp/>=<sp/>mutex_get_owner(mutex);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(owner<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>is<sp/>owned<sp/>by<sp/>task<sp/>%s&quot;,<sp/>task_get_name(owner));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Mutex<sp/>is<sp/>not<sp/>owned&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(20);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="223" column="8" declfile="pros/apix.h" declline="223" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga5a6c741414670ea06a33a740e00a6fb6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="kapi_8h_1ab41e0251d1181d4d91b70a583a372ef2" kindref="member">sem_t</ref></type>
        <definition>sem_t pros::c::sem_create</definition>
        <argsstring>(uint32_t max_count, uint32_t init_count)</argsstring>
        <name>sem_create</name>
        <param>
          <type>uint32_t</type>
          <declname>max_count</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>init_count</declname>
        </param>
        <briefdescription>
<para>Creates a counting sempahore. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>max_count</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum count value that can be reached. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_count</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial count value assigned to the new semaphore.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A newly created semaphore. If an error occurred, NULL will be returned and errno can be checked for hints as to why sem_create failed.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">//<sp/>Binary<sp/>semaphore<sp/>acts<sp/>as<sp/>a<sp/>mutex</highlight></codeline>
<codeline><highlight class="normal">sem_t<sp/>sem<sp/>=<sp/>sem_create(1,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_take(sem,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_give(sem);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="254" column="7" declfile="pros/apix.h" declline="254" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gab5d0d18da11c1a8787a22def530943ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void pros::c::sem_delete</definition>
        <argsstring>(sem_t sem)</argsstring>
        <name>sem_delete</name>
        <param>
          <type><ref refid="kapi_8h_1ab41e0251d1181d4d91b70a583a372ef2" kindref="member">sem_t</ref></type>
          <declname>sem</declname>
        </param>
        <briefdescription>
<para>Deletes a semaphore (or binary semaphore) </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sem</parametername>
</parameternamelist>
<parameterdescription>
<para>Semaphore to delete</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">//<sp/>Binary<sp/>semaphore<sp/>acts<sp/>as<sp/>a<sp/>mutex</highlight></codeline>
<codeline><highlight class="normal">sem_t<sp/>sem<sp/>=<sp/>sem_create(1,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_take(sem,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_give(sem);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(joystick_get_digital(1,<sp/>7,<sp/>JOY_UP))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>honestly<sp/>this<sp/>is<sp/>a<sp/>bad<sp/>example<sp/>because<sp/>you<sp/>should<sp/>never<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>delete<sp/>a<sp/>semaphore<sp/>like<sp/>this</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>sem_delete(sem);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(20);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="291" column="6" declfile="pros/apix.h" declline="291" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gab60398e0ab4ac65a8556dbf67907ad64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="kapi_8h_1ab41e0251d1181d4d91b70a583a372ef2" kindref="member">sem_t</ref></type>
        <definition>sem_t pros::c::sem_binary_create</definition>
        <argsstring>(void)</argsstring>
        <name>sem_binary_create</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Creates a binary semaphore. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A newly created semaphore.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">//<sp/>Binary<sp/>semaphore<sp/>acts<sp/>as<sp/>a<sp/>mutex</highlight></codeline>
<codeline><highlight class="normal">sem_t<sp/>sem<sp/>=<sp/>sem_binary_create();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_take(sem,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_give(sem);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="316" column="7" declfile="pros/apix.h" declline="316" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga29a092d6f1b15aed15a76a79b027ab89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::sem_wait</definition>
        <argsstring>(sem_t sem, uint32_t timeout)</argsstring>
        <name>sem_wait</name>
        <param>
          <type><ref refid="kapi_8h_1ab41e0251d1181d4d91b70a583a372ef2" kindref="member">sem_t</ref></type>
          <declname>sem</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Waits for the semaphore&apos;s value to be greater than 0. </para>
        </briefdescription>
        <detaileddescription>
<para>If the value is already greater than 0, this function immediately returns.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sem</parametername>
</parameternamelist>
<parameterdescription>
<para>Semaphore to wait on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait before the semaphore&apos;s becomes available. A timeout of 0 can be used to poll the sempahore. TIMEOUT_MAX can be used to block indefinitely.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the semaphore was successfully take, false otherwise. If false is returned, then errno is set with a hint about why the sempahore couldn&apos;t be taken.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">//<sp/>Binary<sp/>semaphore<sp/>acts<sp/>as<sp/>a<sp/>mutex</highlight></codeline>
<codeline><highlight class="normal">sem_t<sp/>sem<sp/>=<sp/>sem_create(1,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if(!sem_wait(sem,<sp/>1000))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Failed<sp/>to<sp/>take<sp/>semaphore&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_give(sem);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(sem_wait(sem,<sp/>0)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Semaphore<sp/>is<sp/>available&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(20);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="363" column="6" declfile="pros/apix.h" declline="363" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga1224c0d9b29e68b15971b90d2fdb6f98" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::sem_post</definition>
        <argsstring>(sem_t sem)</argsstring>
        <name>sem_post</name>
        <param>
          <type><ref refid="kapi_8h_1ab41e0251d1181d4d91b70a583a372ef2" kindref="member">sem_t</ref></type>
          <declname>sem</declname>
        </param>
        <briefdescription>
<para>Increments a semaphore&apos;s value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sem</parametername>
</parameternamelist>
<parameterdescription>
<para>Semaphore to post</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the value was incremented, false otherwise. If false is returned, then errno is set with a hint about why the semaphore couldn&apos;t be taken.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">//<sp/>Binary<sp/>semaphore<sp/>acts<sp/>as<sp/>a<sp/>mutex</highlight></codeline>
<codeline><highlight class="normal">sem_t<sp/>sem<sp/>=<sp/>sem_create(1,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>task_fn(void*<sp/>param)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_post(sem);<sp/>//<sp/>increments,<sp/>mimicking<sp/>to<sp/>&quot;claim&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>critical<sp/>section</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sem_give(sem);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>task_delay(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">task_create(task_fn,<sp/>(void*)&quot;PROS&quot;,<sp/>TASK_PRIORITY_DEFAULT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TASK_STACK_DEPTH_DEFAULT,<sp/>&quot;task_fn&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="393" column="6" declfile="pros/apix.h" declline="393" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gae41c284e8d4047254e20c4d5f41a6d5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t pros::c::sem_get_count</definition>
        <argsstring>(sem_t sem)</argsstring>
        <name>sem_get_count</name>
        <param>
          <type><ref refid="kapi_8h_1ab41e0251d1181d4d91b70a583a372ef2" kindref="member">sem_t</ref></type>
          <declname>sem</declname>
        </param>
        <briefdescription>
<para>Returns the current value of the semaphore. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sem</parametername>
</parameternamelist>
<parameterdescription>
<para>A semaphore handle</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The current value of the semaphore (e.g. the number of resources available)</para>
</simplesect>
<bold>Example</bold> of sem_get_count: <programlisting><codeline><highlight class="normal">//<sp/>Binary<sp/>semaphore<sp/>acts<sp/>as<sp/>a<sp/>mutex</highlight></codeline>
<codeline><highlight class="normal">sem_t<sp/>sem<sp/>=<sp/>sem_create(1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;semaphore<sp/>count:<sp/>%d&quot;,<sp/>sem_get_count(sem));</highlight></codeline>
<codeline><highlight class="normal"><sp/>//<sp/>semaphore<sp/>count:<sp/>0</highlight></codeline>
<codeline><highlight class="normal">sem_take(sem,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;semaphore<sp/>count:<sp/>%d&quot;,<sp/>sem_get_count(sem));</highlight></codeline>
<codeline><highlight class="normal"><sp/>//<sp/>semaphore<sp/>count:<sp/>1</highlight></codeline>
<codeline><highlight class="normal">sem_give(sem);</highlight></codeline>
<codeline><highlight class="normal">printf(&quot;semaphore<sp/>count:<sp/>%d&quot;,<sp/>sem_get_count(sem));</highlight></codeline>
<codeline><highlight class="normal"><sp/>//<sp/>semaphore<sp/>count:<sp/>0</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="419" column="10" declfile="pros/apix.h" declline="419" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gae60412052d83e6c9b62ff02398547518" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
        <definition>queue_t pros::c::queue_create</definition>
        <argsstring>(uint32_t length, uint32_t item_size)</argsstring>
        <name>queue_create</name>
        <param>
          <type>uint32_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>item_size</declname>
        </param>
        <briefdescription>
<para>Creates a queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum number of items that the queue can contain. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>item_size</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes each item in the queue will require.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A handle to a newly created queue, or NULL if the queue cannot be created.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>item[10]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6,<sp/>7,<sp/>8,<sp/>9,<sp/>10};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;queue<sp/>length:<sp/>%d&quot;,<sp/>queue_get_length(queue));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="443" column="9" declfile="pros/apix.h" declline="443" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gaa42af929135978ccfd393931ec464980" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::queue_append</definition>
        <argsstring>(queue_t queue, const void *item, uint32_t timeout)</argsstring>
        <name>queue_append</name>
        <param>
          <type><ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>item</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Posts an item to the front of a queue. </para>
        </briefdescription>
        <detaileddescription>
<para>The item is queued by copy, not by reference.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>The queue handle </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>item</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to the item that will be placed on the queue. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for space to become available. A timeout of 0 can be used to attempt to post without blocking. TIMEOUT_MAX can be used to block indefinitely.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the item was preprended, false otherwise.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/>void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>int<sp/>item[10]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6,<sp/>7,<sp/>8,<sp/>9,<sp/>10};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>printf(&quot;queue<sp/>length:<sp/>%d&quot;,<sp/>queue_get_length(queue));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="normal">bool<sp/>queue_prepend(queue_t<sp/>queue,<sp/>const<sp/>void*<sp/>item,<sp/>uint32_t<sp/>timeout);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Posts<sp/>an<sp/>item<sp/>to<sp/>the<sp/>end<sp/>of<sp/>a<sp/>queue.<sp/>The<sp/>item<sp/>is<sp/>queued<sp/>by<sp/>copy,<sp/>not<sp/>by</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>reference.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>queue</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>The<sp/>queue<sp/>handle</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>item</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>pointer<sp/>to<sp/>the<sp/>item<sp/>that<sp/>will<sp/>be<sp/>placed<sp/>on<sp/>the<sp/>queue.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>timeout</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Time<sp/>to<sp/>wait<sp/>for<sp/>space<sp/>to<sp/>become<sp/>available.<sp/>A<sp/>timeout<sp/>of<sp/>0<sp/>can<sp/>be<sp/>used</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to<sp/>attempt<sp/>to<sp/>post<sp/>without<sp/>blocking.<sp/>TIMEOUT_MAX<sp/>can<sp/>be<sp/>used<sp/>to<sp/>block</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indefinitely.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\return<sp/>True<sp/>if<sp/>the<sp/>item<sp/>was<sp/>preprended,<sp/>false<sp/>otherwise.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\b<sp/>Example:</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\code</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>int<sp/>item[10]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6,<sp/>7,<sp/>8,<sp/>9,<sp/>10};</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>printf(&quot;queue<sp/>length:<sp/>%d&quot;,<sp/>queue_get_length(queue));</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/></highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="498" column="6" declfile="pros/apix.h" declline="498" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gaf9b0095a2b8ba4e68b45cebb7105af34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::queue_peek</definition>
        <argsstring>(queue_t queue, void *const buffer, uint32_t timeout)</argsstring>
        <name>queue_peek</name>
        <param>
          <type><ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <param>
          <type>void *const</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Receive an item from a queue without removing the item from the queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>The queue handle </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a buffer to which the received item will be copied </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. TIMEOUT_MAX can be used to block indefinitely.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if an item was copied into the buffer, false otherwise.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char*<sp/>item<sp/>=<sp/>&quot;Hello!<sp/>this<sp/>is<sp/>a<sp/>test&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char*<sp/>recv<sp/>=<sp/>malloc(sizeof(&quot;Hello!<sp/>this<sp/>is<sp/>a<sp/>test&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_peek(queue,<sp/>recv,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Queue:<sp/>%s&quot;,<sp/>recv);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>free(recv);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="527" column="6" declfile="pros/apix.h" declline="527" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga8f80179b408b88dcc17e472816fa89d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool pros::c::queue_recv</definition>
        <argsstring>(queue_t queue, void *const buffer, uint32_t timeout)</argsstring>
        <name>queue_recv</name>
        <param>
          <type><ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <param>
          <type>void *const</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Receive an item from the queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>The queue handle </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to a buffer to which the received item will be copied </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. <ref refid="group__apix_1ga8f80179b408b88dcc17e472816fa89d6" kindref="member">queue_recv()</ref> will return immediately if timeout is zero and the queue is empty.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if an item was copied into the buffer, false otherwise.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char*<sp/>item<sp/>=<sp/>&quot;Hello!<sp/>this<sp/>is<sp/>a<sp/>test&quot;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char*<sp/>recv<sp/>=<sp/>malloc(sizeof(&quot;Hello!<sp/>this<sp/>is<sp/>a<sp/>test&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_recv(queue,<sp/>recv,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Queue:<sp/>%s&quot;,<sp/>recv);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>free(recv);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="558" column="6" declfile="pros/apix.h" declline="558" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga96ad85640c15b62c066ed406be70970b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t pros::c::queue_get_waiting</definition>
        <argsstring>(const queue_t queue)</argsstring>
        <name>queue_get_waiting</name>
        <param>
          <type>const <ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Return the number of messages stored in a queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>The queue handle.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of messages available in the queue.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>item[10]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6,<sp/>7,<sp/>8,<sp/>9,<sp/>10};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;queue<sp/>waiting:<sp/>%d&quot;,<sp/>queue_get_waiting(queue));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="580" column="10" declfile="pros/apix.h" declline="580" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga1b26a8014aaedc3b376c0a2ec3cfc42a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t pros::c::queue_get_available</definition>
        <argsstring>(const queue_t queue)</argsstring>
        <name>queue_get_available</name>
        <param>
          <type>const <ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Return the number of spaces left in a queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>The queue handle.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of spaces available in the queue.</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>item[10]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6,<sp/>7,<sp/>8,<sp/>9,<sp/>10};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;queue<sp/>available:<sp/>%d&quot;,<sp/>queue_get_available(queue));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="602" column="10" declfile="pros/apix.h" declline="602" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga9d976079962026303ca54ec5b6b56ee8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void pros::c::queue_delete</definition>
        <argsstring>(queue_t queue)</argsstring>
        <name>queue_delete</name>
        <param>
          <type><ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Delete a queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>Queue handle to delete</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_delete(queue);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="618" column="6" declfile="pros/apix.h" declline="618" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga65b42a22f90764318ef6ed0f13eeda42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void pros::c::queue_reset</definition>
        <argsstring>(queue_t queue)</argsstring>
        <name>queue_reset</name>
        <param>
          <type><ref refid="kapi_8h_1a5a6f19dc156a45653f8ff36d7beaa168" kindref="member">queue_t</ref></type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Resets a queue to an empty state. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>Queue handle to reset</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_t<sp/>queue<sp/>=<sp/>queue_create(10,<sp/>sizeof(int));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>item[10]<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6,<sp/>7,<sp/>8,<sp/>9,<sp/>10};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_prepend(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_append(queue,<sp/>item,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queue_reset(queue);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="637" column="6" declfile="pros/apix.h" declline="637" declcolumn="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Device Registration</header>
      <memberdef kind="function" id="group__apix_1ga553905fad6df994d7e2ede7cf53b9f83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int pros::c::registry_bind_port</definition>
        <argsstring>(uint8_t port, v5_device_e_t device_type)</argsstring>
        <name>registry_bind_port</name>
        <param>
          <type>uint8_t</type>
          <declname>port</declname>
        </param>
        <param>
          <type>v5_device_e_t</type>
          <declname>device_type</declname>
        </param>
        <briefdescription>
<para>Registers a device in the given zero-indexed port. </para>
        </briefdescription>
        <detaileddescription>
<para>Registers a device of the given type in the given port into the registry, if that type of device is detected to be plugged in to that port.</para>
<para>This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20), or a a different device than specified is plugged in. EADDRINUSE - The port is already registered to another device.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>port</parametername>
</parameternamelist>
<parameterdescription>
<para>The port number to register the device </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>device</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of device to register</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 upon success, PROS_ERR upon failure</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>registry_bind_port(1,<sp/>E_DEVICE_MOTOR);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="670" column="5" declfile="pros/apix.h" declline="670" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gaac4da3ecf327e9d3b68283735650274f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int pros::c::registry_unbind_port</definition>
        <argsstring>(uint8_t port)</argsstring>
        <name>registry_unbind_port</name>
        <param>
          <type>uint8_t</type>
          <declname>port</declname>
        </param>
        <briefdescription>
<para>Deregisters a devices from the given zero-indexed port. </para>
        </briefdescription>
        <detaileddescription>
<para>Removes the device registed in the given port, if there is one.</para>
<para>This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>port</parametername>
</parameternamelist>
<parameterdescription>
<para>The port number to deregister</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 upon success, PROS_ERR upon failure</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>registry_bind_port(1,<sp/>E_DEVICE_MOTOR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>registry_unbind_port(1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="694" column="5" declfile="pros/apix.h" declline="694" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga0cd9577a7facb56ef145e9508849a395" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>v5_device_e_t</type>
        <definition>v5_device_e_t pros::c::registry_get_bound_type</definition>
        <argsstring>(uint8_t port)</argsstring>
        <name>registry_get_bound_type</name>
        <param>
          <type>uint8_t</type>
          <declname>port</declname>
        </param>
        <briefdescription>
<para>Returns the type of device registered to the zero-indexed port. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>port</parametername>
</parameternamelist>
<parameterdescription>
<para>The V5 port number from 0-20</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The type of device that is registered into the port (NOT what is plugged in)</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>registry_bind_port(1,<sp/>E_DEVICE_MOTOR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;port<sp/>1<sp/>is<sp/>registered<sp/>to<sp/>a<sp/>motor:<sp/>%d&quot;,<sp/>registry_get_bound_type(1)<sp/>==<sp/>E_DEVICE_MOTOR);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="717" column="15" declfile="pros/apix.h" declline="717" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gaf7b9f904f53cb888950c0e8752354937" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>v5_device_e_t</type>
        <definition>v5_device_e_t pros::c::registry_get_plugged_type</definition>
        <argsstring>(uint8_t port)</argsstring>
        <name>registry_get_plugged_type</name>
        <param>
          <type>uint8_t</type>
          <declname>port</declname>
        </param>
        <briefdescription>
<para>Returns the type of the device plugged into the zero-indexed port. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>port</parametername>
</parameternamelist>
<parameterdescription>
<para>The V5 port number from 0-20</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The type of device that is plugged into the port (NOT what is registered)</para>
</simplesect>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal">void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>registry_bind_port(1,<sp/>E_DEVICE_MOTOR);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;port<sp/>1<sp/>is<sp/>registered<sp/>to<sp/>a<sp/>motor:<sp/>%d&quot;,<sp/>registry_get_plugged_type(1)<sp/>==<sp/>E_DEVICE_MOTOR);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="740" column="15" declfile="pros/apix.h" declline="740" declcolumn="15"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Filesystem</header>
      <memberdef kind="define" id="group__apix_1ga597a3aaaad99225156c5940db91ed7e7" prot="public" static="no">
        <name>SERCTL_ACTIVATE</name>
        <initializer>10</initializer>
        <briefdescription>
<para>Action macro to pass into serctl or fdctl that activates the stream identifier. </para>
        </briefdescription>
        <detaileddescription>
<para>When used with serctl, the extra argument must be the little endian representation of the stream identifier (e.g. &quot;sout&quot; -&gt; 0x74756f73) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="859" column="9" bodyfile="pros/apix.h" bodystart="859" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1gaa07c3d6750babcc306ece8dd1b18ec26" prot="public" static="no">
        <name>SERCTL_DEACTIVATE</name>
        <initializer>11</initializer>
        <briefdescription>
<para>Action macro to pass into serctl or fdctl that deactivates the stream identifier. </para>
        </briefdescription>
        <detaileddescription>
<para>When used with serctl, the extra argument must be the little endian representation of the stream identifier (e.g. &quot;sout&quot; -&gt; 0x74756f73) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="869" column="9" bodyfile="pros/apix.h" bodystart="869" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1ga487ad68591182ba67ceb987f59f31fab" prot="public" static="no">
        <name>SERCTL_BLKWRITE</name>
        <initializer>12</initializer>
        <briefdescription>
<para>Action macro to pass into fdctl that enables blocking writes for the file. </para>
        </briefdescription>
        <detaileddescription>
<para>The extra argument is not used with this action, provide any value (e.g. NULL) instead </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="878" column="9" bodyfile="pros/apix.h" bodystart="878" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1ga48765184fb0f8084d9cebf9dcbc27da7" prot="public" static="no">
        <name>SERCTL_NOBLKWRITE</name>
        <initializer>13</initializer>
        <briefdescription>
<para>Action macro to pass into fdctl that makes writes non-blocking for the file. </para>
        </briefdescription>
        <detaileddescription>
<para>The extra argument is not used with this action, provide any value (e.g. NULL) instead </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="887" column="9" bodyfile="pros/apix.h" bodystart="887" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1ga20c46bffd0ef8939413f671a5ac92252" prot="public" static="no">
        <name>SERCTL_ENABLE_COBS</name>
        <initializer>14</initializer>
        <briefdescription>
<para>Action macro to pass into serctl that enables advanced stream multiplexing capabilities. </para>
        </briefdescription>
        <detaileddescription>
<para>The extra argument is not used with this action, provide any value (e.g. NULL) instead </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="897" column="9" bodyfile="pros/apix.h" bodystart="897" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1ga9a50f0ab303c00138f09df10358b01c4" prot="public" static="no">
        <name>SERCTL_DISABLE_COBS</name>
        <initializer>15</initializer>
        <briefdescription>
<para>Action macro to pass into serctl that disables advanced stream multiplexing capabilities. </para>
        </briefdescription>
        <detaileddescription>
<para>The extra argument is not used with this action, provide any value (e.g. NULL) instead </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="907" column="9" bodyfile="pros/apix.h" bodystart="907" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1gad7e4ecbf8e36a784cdf4d245cd3c7d1d" prot="public" static="no">
        <name>DEVCTL_FIONREAD</name>
        <initializer>16</initializer>
        <briefdescription>
<para>Action macro to check if there is data available from the Generic Serial Device. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="914" column="9" bodyfile="pros/apix.h" bodystart="914" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1ga0089c4b06b9b75f4995256ca740f8ee2" prot="public" static="no">
        <name>DEVCTL_FIONWRITE</name>
        <initializer>18</initializer>
        <briefdescription>
<para>Action macro to check if there is space available in the Generic Serial Device&apos;s output buffer. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="921" column="9" bodyfile="pros/apix.h" bodystart="921" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__apix_1ga5ac3b151b46b5bfce1ec424b5fdc773b" prot="public" static="no">
        <name>DEVCTL_SET_BAUDRATE</name>
        <initializer>17</initializer>
        <briefdescription>
<para>Action macro to set the Generic Serial Device&apos;s baudrate. </para>
        </briefdescription>
        <detaileddescription>
<para>The extra argument is the baudrate. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="928" column="9" bodyfile="pros/apix.h" bodystart="928" bodyend="-1"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1ga01b62747fbed77dcd50879d4d557adfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t pros::c::fdctl</definition>
        <argsstring>(int file, const uint32_t action, void *const extra_arg)</argsstring>
        <name>fdctl</name>
        <param>
          <type>int</type>
          <declname>file</declname>
        </param>
        <param>
          <type>const uint32_t</type>
          <declname>action</declname>
        </param>
        <param>
          <type>void *const</type>
          <declname>extra_arg</declname>
        </param>
        <briefdescription>
<para>Control settings of the serial driver. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>An action to perform on the serial driver. See the SERCTL_* macros for details on the different actions. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>extra_arg</parametername>
</parameternamelist>
<parameterdescription>
<para>An argument to pass in based on the action</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Example:</bold> <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/>void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>serctl(SERCTL_SET_BAUDRATE,<sp/>(void*)<sp/>9600);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/</highlight></codeline>
<codeline><highlight class="normal">int32_t<sp/>serctl(const<sp/>uint32_t<sp/>action,<sp/>void*<sp/>const<sp/>extra_arg);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Control<sp/>settings<sp/>of<sp/>the<sp/>microSD<sp/>card<sp/>driver.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>action</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>An<sp/>action<sp/>to<sp/>perform<sp/>on<sp/>the<sp/>microSD<sp/>card<sp/>driver.<sp/>See<sp/>the<sp/>USDCTL_*<sp/>macros</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>details<sp/>on<sp/>the<sp/>different<sp/>actions.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>extra_arg</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>An<sp/>argument<sp/>to<sp/>pass<sp/>in<sp/>based<sp/>on<sp/>the<sp/>action</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Not<sp/>yet<sp/>implemented</highlight></codeline>
<codeline><highlight class="normal">//<sp/>int32_t<sp/>usdctl(const<sp/>uint32_t<sp/>action,<sp/>void*<sp/>const<sp/>extra_arg);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Control<sp/>settings<sp/>of<sp/>the<sp/>way<sp/>the<sp/>file&apos;s<sp/>driver<sp/>treats<sp/>the<sp/>file</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>file</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>valid<sp/>file<sp/>descriptor<sp/>number</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>action</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>An<sp/>action<sp/>to<sp/>perform<sp/>on<sp/>the<sp/>file&apos;s<sp/>driver.<sp/>See<sp/>the<sp/>*CTL_*<sp/>macros<sp/>for</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>details<sp/>on<sp/>the<sp/>different<sp/>actions.<sp/>Note<sp/>that<sp/>the<sp/>action<sp/>passed<sp/>in<sp/>must</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>match<sp/>the<sp/>correct<sp/>driver<sp/>(e.g.<sp/>don&apos;t<sp/>perform<sp/>a<sp/>SERCTL_*<sp/>action<sp/>on<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>microSD<sp/>card<sp/>file)</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\param<sp/>extra_arg</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>An<sp/>argument<sp/>to<sp/>pass<sp/>in<sp/>based<sp/>on<sp/>the<sp/>action</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\b<sp/>Example:</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>\code</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>void<sp/>opcontrol(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>int32_t<sp/>fd<sp/>=<sp/>open(&quot;serial&quot;,<sp/>O_RDWR);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/>fdctl(fd,<sp/>SERCTL_SET_BAUDRATE,<sp/>(void*)<sp/>9600);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/></highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="797" column="9" declfile="pros/apix.h" declline="797" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gaad01c082a5899e0ab42abdda37d3d425" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t pros::c::motor_set_reversed</definition>
        <argsstring>(int8_t port, const bool reverse)</argsstring>
        <name>motor_set_reversed</name>
        <param>
          <type>int8_t</type>
          <declname>port</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>reverse</declname>
        </param>
        <briefdescription>
<para>Sets the reverse flag for the motor. </para>
        </briefdescription>
        <detaileddescription>
<para>This will invert its movements and the values returned for its position.</para>
<para>This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (1-21). ENODEV - The port cannot be configured as a motor</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>port</parametername>
</parameternamelist>
<parameterdescription>
<para>The V5 port number from 1-21 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reverse</parametername>
</parameternamelist>
<parameterdescription>
<para>True reverses the motor, false is default</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the operation was successful or PROS_ERR if the operation failed, setting errno.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>autonomous()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>motor_set_reversed(1,<sp/>true);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Is<sp/>this<sp/>motor<sp/>reversed?<sp/>%d\n&quot;,<sp/>motor_is_reversed(1));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="825" column="9" declfile="pros/apix.h" declline="825" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__apix_1gad78caa8efd1b34a316037a036f1f2ba6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t pros::c::motor_is_reversed</definition>
        <argsstring>(int8_t port)</argsstring>
        <name>motor_is_reversed</name>
        <param>
          <type>int8_t</type>
          <declname>port</declname>
        </param>
        <briefdescription>
<para>Gets the operation direction of the motor as set by the user. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (1-21). ENODEV - The port cannot be configured as a motor</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>port</parametername>
</parameternamelist>
<parameterdescription>
<para>The V5 port number from 1-21</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if the motor has been reversed and 0 if the motor was not reversed, or PROS_ERR if the operation failed, setting errno.</para>
</simplesect>
<bold>Example</bold> <programlisting><codeline><highlight class="normal">void<sp/>initialize()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>printf(&quot;Is<sp/>the<sp/>motor<sp/>reversed?<sp/>%d\n&quot;,<sp/>motor_is_reversed(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Prints<sp/>&quot;Is<sp/>the<sp/>motor<sp/>reversed?<sp/>0&quot;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pros/apix.h" line="849" column="9" declfile="pros/apix.h" declline="849" declcolumn="9"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>PROS Extended API header</para>
<para>Contains additional declarations for use by advaned users of PROS. These functions do not typically have as much error handling or require deeper knowledge of real time operating systems.</para>
<para>This file should not be modified by users, since it gets replaced whenever a kernel upgrade occurs.</para>
<para><simplesect kind="copyright"><para>(c) 2017-2023, Purdue University ACM SIGBots. All rights reserved.</para>
</simplesect>
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <ulink url="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</ulink>. </para>
    </detaileddescription>
    <location file="pros/apix.h"/>
  </compounddef>
</doxygen>
