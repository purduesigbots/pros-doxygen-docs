Learning a new coding platform is often a rather daunting task. For this reason we prepared some small tutorials with examples on how to interact with core components of P\+R\+OS on your V\+EX V5 system.

The P\+R\+OS tutorials are split into three sections\+:\hypertarget{tutorials_autotoc_md26}{}\doxysubsection{General Tutorials}\label{tutorials_autotoc_md26}
If you\textquotesingle{}re still new to writing software or P\+R\+OS, and looking for additional information beyond our \mbox{\hyperlink{getting-started}{Getting Started}} guides, the {\bfseries{General Tutorials}} are a great resource for topics like debugging and the P\+R\+OS project structure.


\begin{DoxyItemize}
\item \mbox{\hyperlink{coding-faq}{Coding F\+AQ}}
\item \mbox{\hyperlink{combining-c-cpp}{Combining C and C++}}
\item \mbox{\hyperlink{debugging}{Debugging}}
\item \mbox{\hyperlink{project-structure}{Project Structure}}
\item \mbox{\hyperlink{usage-faq}{General Usage F\+AQ}}
\end{DoxyItemize}\hypertarget{tutorials_autotoc_md27}{}\doxysubsection{Walkthrough Tutorials}\label{tutorials_autotoc_md27}
If you want to write full sample programs to learn to use P\+R\+OS through practical applications, or teach students to use P\+R\+OS in a classroom environment, the {\bfseries{Walkthrough Tutorials}} are a great resource to go step by step through the process of writing a P\+R\+OS program.


\begin{DoxyItemize}
\item \mbox{\hyperlink{clawbot}{Programming the Clawbot}}
\item \mbox{\hyperlink{creating-c-project}{Creating a C Project}}
\end{DoxyItemize}\hypertarget{tutorials_autotoc_md28}{}\doxysubsection{Topical Tutorials}\label{tutorials_autotoc_md28}
If you want more information about using a particular part of the api, the {\bfseries{Topical Tutorials}} offer longer examples and more detail about using the P\+R\+OS A\+PI. \hypertarget{coding-faq}{}\doxysection{Coding F\+AQ}\label{coding-faq}
\begin{quote}

\begin{DoxyItemize}
\item {\ttfamily \char`\"{}main.\+h\char`\"{} file not found}\+:
\item {\ttfamily \char`\"{}main.\+h\char`\"{} file not found}\+: \+: This error occurs when the compilation database {\ttfamily compile\+\_\+commands.\+json} is not up to date. The file contains the exact compiler calls of the project, and should be automatically populated when the code is compiled. If you see this error just after creating a project, it could be because the project was created using the C\+LI without the after creating the project. Regardless of when this issue after creating the project. Regardless of when this issue appears, running {\ttfamily pros make all} in the C\+LI or running {\ttfamily P\+R\+OS -\/$>$ Build -\/$>$ All} in the editor, the whole project is compiled again, fixing this issue. You may need to close and reopen any files in order for the linter to catch up. It is also possible that a compilation error was not caught by the linter, so running a full build will help discover these hidden errors. 
\end{DoxyItemize}\end{quote}
\hypertarget{coding-faq_autotoc_md17}{}\doxysubsubsection{Compile-\/\+Time Issues}\label{coding-faq_autotoc_md17}
\begin{quote}

\begin{DoxyItemize}
\item {\ttfamily undefined reference to ...} or {\ttfamily implicit declaration of function ...}\+: \+: A function name is spelled incorrectly, or the function was incorrectly declared in a header file. Custom headers must be included in {\ttfamily \mbox{\hyperlink{main_8h}{main.\+h}}} or in the file in which they are used.
\item {\ttfamily format ... expects argument of type ..., but argument has type ...}\+: \+: The value provided to a function like \href{http://www.cplusplus.com/reference/cstdio/printf/}{\texttt{ printf}} or \href{../../api/c/llemu.html\#lcd-print}{\texttt{ lcd\+\_\+print}} does not match the expected type inferred from the format string. Some instances of this warning can be safely ignored, but crashes can occur if types {\ttfamily double} or {\ttfamily long long} are mixed with other types.
\item {\ttfamily assignment makes pointer from integer without a cast}\+: \+: Typically caused when a C pointer has the wrong number of asterisks to \href{http://stackoverflow.com/a/4955297/3681958}{\texttt{ dereference}} it, or when assigning a constant to {\ttfamily pointer} (instead of {\ttfamily $\ast$pointer}). 
\end{DoxyItemize}\end{quote}
\hypertarget{coding-faq_autotoc_md18}{}\doxysubsubsection{Run-\/\+Time Issues}\label{coding-faq_autotoc_md18}
\begin{quote}

\begin{DoxyItemize}
\item {\bfseries{Some tasks are running, others are not\+:}} \+: A task is not waiting using \href{../../api/c/rtos.html\#delay}{\texttt{ delay}} or \href{../../api/c/rtos.html\#task-delay-until}{\texttt{ task\+\_\+delay\+\_\+until}}. Due to the fact that P\+R\+OS utilizes a priority based non-\/preemptive scheduler, tasks of higher or equal priority to the blocking task will still run while lower priority tasks will not. This scenario is also known as \href{https://en.wikipedia.org/wiki/Starvation_(computer_science)}{\texttt{ starvation}}. See \href{/tutorials/topical/multitasking}{\texttt{ Tasks/\+Multithreading}} for more information.
\item {\bfseries{V\+EX L\+CD updates very slowly or is \char`\"{}frozen\char`\"{}\+:}} \+: A task is not waiting using \href{../../api/c/rtos.html\#delay}{\texttt{ delay}} or From the kernel\textquotesingle{}s perspective, updating the L\+CD is usually less important than how well the robot is running, so P\+R\+OS prioritizes user tasks over the L\+CD. \begin{DoxyVerb}The LCD is only updated if all other tasks are waiting.
\end{DoxyVerb}

\item {\bfseries{Neither autonomous nor driver control code starts\+:}} \+: The {\ttfamily \mbox{\hyperlink{main_8h_a9efe22aaead3a5e936b5df459de02eba}{initialize()}}} function may still be running. Some tasks such as \href{../../api/c/adi.html\#analog-calibrate}{\texttt{ analog\+\_\+calibrate}} take time. \begin{DoxyVerb}If the `initialize()` function implements some type of loop or
autonomous selection routine, verify that it actually has a
means of ending.
\end{DoxyVerb}

\item {\bfseries{Code restarts unexpectedly\+:}} \+: A run-\/time error has caused the program to crash. \href{./debugging}{\texttt{ Debugging}} may reveal the cause of the error. Examine any newly added code for possible logical errors. Some common error messages include\+:
\begin{DoxyItemize}
\item {\bfseries{Segmentation Fault\+:}} \+: Indicates that an invalid C pointer has been used. Check for confusion between pointers and regular variables and that an invalid pointer has not been passed to a P\+R\+OS A\+PI function.
\item {\bfseries{Stack Overflow\+:}} \+: Often indicates infinite recursion, or that the stack size for a custom task is too small. Calling many layers of functions and declaring large local variables can require large amounts of space on the stack. If this error occurs in a default task like {\ttfamily \mbox{\hyperlink{main_8h_a2df3d06bc5bced154da27fce393f991f}{autonomous()}}}, consider changing code to reduce the stack requirements, or creating a new task with a larger stack size using \href{../../api/c/rtos.html\#task_create}{\texttt{ task\+\_\+create}} to handle large jobs. Large arrays declared inside functions can usually be declared globally to alleviate pressure on stack space.
\item {\bfseries{System Task Failure\+:}} \+: Too many tasks were running for the system to start a new one. Disable or merge unnecessary tasks to eliminate this error.
\end{DoxyItemize}
\item {\bfseries{Cortex blinking red light after upload\+:}} \+: Turn the Cortex microcontroller off and on again. This usually resolves the problem, and it is generally good practice to re-\/initialize the robot to simulate conditions at most competitions. If the error persists, see the \char`\"{}$\ast$$\ast$\+Code restarts
  unexpectedly$\ast$$\ast$\char`\"{} section above.
\item \mbox{[}printf\mbox{]}(printf\+\_\+) {\bfseries{doesn\textquotesingle{}t work}}\+:
\item \mbox{[}printf\mbox{]}(printf\+\_\+) {\bfseries{doesn\textquotesingle{}t work}}\+: \+: \href{http://www.cplusplus.com/reference/cstdio/printf/}{\texttt{ printf}} prints information over a serial connection (\href{../tutorials/general/debugging}{\texttt{ Debugging}}), not to the V\+EX L\+CD. To print to the L\+CD, use \href{../../api/c/llemu.html\#lcd-print}{\texttt{ lcd\+\_\+print}} instead. 
\end{DoxyItemize}\end{quote}
\hypertarget{combining-c-cpp}{}\doxysection{Combining C and C++}\label{combining-c-cpp}
The P\+R\+OS C and C++ A\+P\+Is cover the exact same feature set, which means that there is no significant advantage to using functions from one A\+PI in another language. However, if you do find yourself wanting to use C A\+PI functions in C++, these functions are accessible through the namespace {\ttfamily pros\+::c}.

This can also be done by using the {\ttfamily pros\+::c} namespace as such\+: \begin{DoxyVerb}using namespace pros::c;
\end{DoxyVerb}


As always, bear in mind the dangers of setting a global namespace and only use the {\ttfamily using} keyword in appropriate scopes.

For guidance on mixing C and C++ code with code you\textquotesingle{}ve written, see \href{https://isocpp.org/wiki/faq/mixing-c-and-cpp}{\texttt{ this tutorial}}. \hypertarget{debugging}{}\doxysection{Debugging}\label{debugging}
\begin{quote}
{\bfseries{warning}}

This content is subject to change as the P\+R\+OS C\+LI for V5 is created. \end{quote}


The \href{../../api/index.html}{\texttt{ P\+R\+OS A\+PI}} provides functions like \href{http://www.cplusplus.com/reference/cstdio/printf/}{\texttt{ printf}} that allow your robot to output information to a connected serial console during operation.\hypertarget{debugging_autotoc_md19}{}\doxysubsubsection{Viewing printf output}\label{debugging_autotoc_md19}
To view a robot\textquotesingle{}s output, there are two officially supported methods\+:


\begin{DoxyEnumerate}
\item Through the P\+R\+OS C\+LI\+:

Running {\ttfamily prosv5 terminal} on the command line will open an output stream from a robot connected over direct U\+SB connection, V\+E\+Xnet, or \href{./tutorials/topical/jinx.html}{\texttt{ J\+I\+NX}}.
\item From within Atom\+:

Click the button labeled \char`\"{}\+Open cortex serial output\char`\"{}
\end{DoxyEnumerate}



A terminal panel will open at the bottom of the screen containing the output of a connected robot.

\hypertarget{debugging_autotoc_md20}{}\doxysubsubsection{Further debug info with $<$tt$>$errno$<$/tt$>$}\label{debugging_autotoc_md20}
{\ttfamily errno} is a global value that is set when any part of the P\+R\+OS kernel encounters an error. The value of {\ttfamily errno} is specific to each function, so check the function headers or the \href{../../api/index.html}{\texttt{ A\+PI docs}} for possible values and their meaning. If you think you\textquotesingle{}re encountering an error in the kernel code, check the value of {\ttfamily errno} to see what\textquotesingle{}s causing the issue.

Debugging in this manner is standard to other environments besides P\+R\+OS. For further information on using {\ttfamily errno}, see the following tutorial\+: \href{https://www.tutorialspoint.com/cprogramming/c_error_handling.htm}{\texttt{ https\+://www.\+tutorialspoint.\+com/cprogramming/c\+\_\+error\+\_\+handling.\+htm}}\hypertarget{debugging_autotoc_md21}{}\doxysubsubsection{J\+I\+N\+X Graphical Debugger}\label{debugging_autotoc_md21}
J\+I\+NX offers further debugging functionality over traditional debugging through print statements. For a full explanation of J\+I\+NX\textquotesingle{}s abilities and its use, see ../topical/jinx. \hypertarget{project-structure}{}\doxysection{Project Structure}\label{project-structure}
P\+R\+OS projects are internally composed of three parts\+: the {\bfseries{P\+R\+OS library}} (found in {\ttfamily /firmware}), the {\bfseries{header}} files (found in {\ttfamily /include}), and {\bfseries{user code}} (found in {\ttfamily /src}).\hypertarget{project-structure_autotoc_md22}{}\doxysubsubsection{firmware}\label{project-structure_autotoc_md22}
The {\bfseries{P\+R\+OS library}} is a single file containing the core P\+R\+OS routines. This file does not need to be changed. If there appears to be an issue with a core P\+R\+OS function, please file an issue on \href{https://github.com/purduesigbots/pros/issues}{\texttt{ Git\+Hub}}.\hypertarget{project-structure_autotoc_md23}{}\doxysubsubsection{include}\label{project-structure_autotoc_md23}
The {\bfseries{header}} files are all found in the {\ttfamily include} directory. One header file, \href{../../api/index.html}{\texttt{ api.\+h}}, is required to declare the P\+R\+OS library functions. This file exists merely to include the individual P\+R\+OS A\+PI headers, all of which can be found in {\ttfamily include/pros}. Each header file in this directory covers a specific aspect of interacting with the V5 hardware, and correlates to the files found in the \href{../../api/index.html}{\texttt{ A\+PI documentation}}.

The other file, {\ttfamily \mbox{\hyperlink{main_8h}{main.\+h}}}, is intended for declaring functions and variables shared between the user code files. {\ttfamily \mbox{\hyperlink{main_8h}{main.\+h}}} also offers a variety of configurable options for tailoring P\+R\+OS to your needs.


\begin{DoxyItemize}
\item {\ttfamily P\+R\+O\+S\+\_\+\+U\+S\+E\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+N\+A\+M\+ES}\+: If defined, some commonly used enums will have preprocessor macros which give a shorter, more convenient naming pattern. For instance, E\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+M\+A\+S\+T\+ER has a shorter name\+: {\ttfamily C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+M\+A\+S\+T\+ER}. {\ttfamily E\+\_\+\+C\+O\+N\+T\+R\+O\+L\+L\+E\+R\+\_\+\+M\+A\+S\+T\+ER} is pedantically correct within the P\+R\+OS styleguide, but not convenient for most student programmers.
\item {\ttfamily using namespace pros}\+: This can be uncommented to be added with the use of {\ttfamily P\+R\+O\+S\+\_\+\+U\+S\+E\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+N\+A\+M\+ES}. This reduces the length of declarations when using C++, allowing you to simply declare a {\ttfamily Motor} instead of a {\ttfamily \mbox{\hyperlink{classpros_1_1Motor}{pros\+::\+Motor}}}. This will make the code appear cleaner and will be simpler for newer programmers, but is typically considered \href{https://msdn.microsoft.com/en-us/library/5cb46ksf.aspx}{\texttt{ bad practice}}. As a result, this line is commented out by default.
\end{DoxyItemize}

New header files can be created in the include directory, as long as the name ends with {\ttfamily .h} (Traditionally for C files) or {\ttfamily .hpp} (for C++ files). See this \href{http://www.learncpp.com/cpp-tutorial/19-header-files/}{\texttt{ C++ tutorial}} for more information on how to create header files.\hypertarget{project-structure_autotoc_md24}{}\doxysubsubsection{src}\label{project-structure_autotoc_md24}
{\bfseries{User code}} has the actual sequential instructions that govern the robot\textquotesingle{}s behavior. Prior to P\+R\+OS kernel 3.\+2.\+0, new projects by default split user code into autonomous ({\ttfamily autonomous.\+c} or {\ttfamily autonomous.\+cpp}), driver control ({\ttfamily opcontrol.\+c} or {\ttfamily opcontrol.\+cpp}), and initialization ({\ttfamily initialize.\+c} or {\ttfamily initialize.\+cpp}) files. Code in one file can talk to code in another file using declarations in the header files. Beginning with P\+R\+OS kernel 3.\+2.\+0, new projects by default have a single {\ttfamily main.\+cpp} file that contains all of the competition task functions.

New user code files can be created in the {\ttfamily src} directory, as long as the name ends with {\ttfamily .c} or {\ttfamily .cpp} it will be compiled with the others.

All user code files should start with\+: \begin{DoxyVerb}#include "main.h"
\end{DoxyVerb}


This will ensure that the P\+R\+OS A\+PI and other critical definitions are available in each file.

While more complicated than some environments, splitting up code grants powerful modularity and code reusability, especially when combined with source control. \hypertarget{usage-faq}{}\doxysection{General Usage F\+AQ}\label{usage-faq}
\hypertarget{usage-faq_autotoc_md25}{}\doxysubsubsection{Why do I get a \char`\"{}\+Could not open port\char`\"{} error when flashing?}\label{usage-faq_autotoc_md25}
You might have seen an error like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Uploading bin/output.bin to v5 device on COM11 as hello to slot 1}
\DoxyCodeLine{ERROR -\/ pros.cli.upload:upload -\/ could not open port 'COM11': PermissionError(13, 'Access is denied.', None, 5)}
\DoxyCodeLine{File "c:\(\backslash\)users\(\backslash\)jonathan\(\backslash\)appdata\(\backslash\)local\(\backslash\)programs\(\backslash\)python\(\backslash\)python36-\/32\(\backslash\)lib\(\backslash\)site-\/packages\(\backslash\)serial\(\backslash\)serialwin32.py", line 62, in open}
\DoxyCodeLine{  raise SerialException("could not open port \{!r\}: \{!r\}".format(self.portstr, ctypes.WinError()))}
\DoxyCodeLine{serial.serialutil.SerialException: could not open port 'COM11': PermissionError(13, 'Access is denied.', None, 5)}
\end{DoxyCode}


That means that some other resource is using the port. If you also have the V5 Utility open, that would cause this error to occur. Close the V5 Utility if you want to flash. \hypertarget{clawbot}{}\doxysection{Programming the Clawbot}\label{clawbot}
\hypertarget{clawbot_autotoc_md77}{}\doxysubsubsection{Objective}\label{clawbot_autotoc_md77}
This tutorial will guide you through basic programming of the V\+EX Clawbot.\hypertarget{clawbot_autotoc_md78}{}\doxysubsubsection{Intended Audience}\label{clawbot_autotoc_md78}
This tutorial is intended for developers with some programming experience, but with little to no experience with the P\+R\+OS library. If you haven\textquotesingle{}t programmed before, we recommend checking out all the \char`\"{}\+Introduction and Basic C Features\char`\"{} sections of \href{http://www.studytonight.com/c/overview-of-c.php}{\texttt{ this tutorial series}}; you may also benefit from the \char`\"{}\+Pointers, Arrays and Strings\char`\"{} sections as well (although they aren\textquotesingle{}t as pertinent).\hypertarget{clawbot_autotoc_md79}{}\doxysubsubsection{Goals}\label{clawbot_autotoc_md79}
At the end of this tutorial you will have\+:


\begin{DoxyItemize}
\item Understood the basic project structure of P\+R\+OS
\item Programmed a basic chassis with \char`\"{}tank\char`\"{} control or \char`\"{}arcade\char`\"{} control
\item Programmed buttons to control the clawbot\textquotesingle{}s lift
\item Programmed a joystick axis to control the clawbot\textquotesingle{}s claw
\item Understood the standard subsystem module methodology
\item Programmed a dead-\/reckoned autonomous routine
\end{DoxyItemize}\hypertarget{clawbot_autotoc_md80}{}\doxysubsubsection{The Clawbot}\label{clawbot_autotoc_md80}
Here\textquotesingle{}s the robot we\textquotesingle{}ll be programming\+:



You can follow V\+EX\textquotesingle{}s tutorial for building this robot \href{https://v5beta.vex.com/parent-wrapper.php?id=v5-with-clawbot}{\texttt{ here}}.

For the purposes of this tutorial, we\textquotesingle{}ve plugged in our motors into the following ports\+:

Port Description Port Description

\DoxyHorRuler{0}


1 Left Wheels 11 ~\newline
 2 12 ~\newline
 3 Claw Motor 13 ~\newline
 4 14 ~\newline
 5 Vision Sensor 15 ~\newline
 6 16 ~\newline
 7 17 ~\newline
 8 Arm Motor 18 ~\newline
 9 19 ~\newline
 10 Right Wheels 20

Port 21\+: Radio

For the A\+DI\+:

Port Description Port Description

\DoxyHorRuler{0}


A Left Bumper E ~\newline
 B Right Bumper F ~\newline
 C G ~\newline
 D H Arm Limit\hypertarget{clawbot_autotoc_md83}{}\doxysubsubsection{Creating the Project}\label{clawbot_autotoc_md83}
With Atom started, you can create a new P\+R\+OS project by clicking the {\ttfamily P\+R\+OS} menu, then click {\ttfamily Create new Project}.

Create a directory that you\textquotesingle{}d like to keep the source files for your Clawbot project.

Pick a directory to create the new project in and click Create. The P\+R\+OS C\+LI will now copy the latest kernel template into the specified directory and Atom will open it.\hypertarget{clawbot_autotoc_md84}{}\doxysubsubsection{P\+R\+O\+S Project Structure}\label{clawbot_autotoc_md84}
When you create your project, P\+R\+OS will copy all of the files necessary to build your project. The structure of the project looks like\+:

\begin{quote}
{\bfseries{note}}

Prior to P\+R\+OS kernel 3.\+2.\+0, the {\ttfamily \mbox{\hyperlink{main_8h_a1903abdb5ef0f301d660754c8315fc17}{opcontrol()}}}, {\ttfamily \mbox{\hyperlink{main_8h_a2df3d06bc5bced154da27fce393f991f}{autonomous()}}}, and initialize functions are separated into separate files (opcontrol.\+cpp, autonomous.\+cpp, and initialize.\+cpp). After P\+R\+OS kernel 3.\+2.\+0, they are by default kept in one file (main.\+cpp). These could be separated again if you so wish. \end{quote}
\hypertarget{clawbot_autotoc_md85}{}\doxysubsubsection{Drive Control}\label{clawbot_autotoc_md85}
Let\textquotesingle{}s start with the simplest operator control setup for the clawbot -\/ tank drive control. We\textquotesingle{}ll map the controller\textquotesingle{}s left joystick to the left drive motor and the controller\textquotesingle{}s right joystick to the right drive motor.

The controller joystick can be read with the following function\+:

And we\textquotesingle{}ll set the motors with the following function\+:

Before we get started with the tank drive control, it\textquotesingle{}s important to note that in C++, smart devices have constructors that create the smart device object. Constructors are a standard C++ concept, and they\textquotesingle{}re very important because a constructor is necessary to define a class for objects like the motors and controllers.

We\textquotesingle{}ll be calling the constructors for the motors and controller at the beginning of {\ttfamily \mbox{\hyperlink{main_8h_a1903abdb5ef0f301d660754c8315fc17}{opcontrol()}}}, and then we\textquotesingle{}ll run the tank drive code.

To test this code, run the following commands in the terminal window to create, build, and upload the code.

These 2 commands can be simplified to {\ttfamily \`{}prosv5 mu}.\hypertarget{clawbot_autotoc_md86}{}\doxysubsubsection{Arcade Control}\label{clawbot_autotoc_md86}
While tank drive control is perfectly suitable for the driving style of some individuals, it is worth covering the arcade control method as well. This is similar to the movement style of many video games, where one joystick axis covers forward/backward movement and the other joystick covers turning.

We will take the previous tank drive control code and modify it slightly to become arcade control. The sum or difference of the power and turn joysticks will be the power values sent to the left and right wheels.

As with the tank drive code, this can be uploaded with the {\ttfamily prosv5 mu} command.\hypertarget{clawbot_autotoc_md87}{}\doxysubsubsection{Arm Control}\label{clawbot_autotoc_md87}
Next let\textquotesingle{}s control the clawbot\textquotesingle{}s arm. This will not require the use of a joystick, but instead we will use the controller\textquotesingle{}s buttons.

We will use the following function to read the button press from the controller\+:

We will use a different motor movement function than on the drivetrain. By using the velocity-\/controlled movement functions, we can ensure that the lift moves at a constant speed regardless of the weight that the lift is holding.

To actuate the lift, we will check if the upmost right trigger is pressed or if the bottommost right trigger is pressed on the controller, and move the lift in that direction if so.\hypertarget{clawbot_autotoc_md88}{}\doxysubsubsection{Claw Control}\label{clawbot_autotoc_md88}
We will control the claw in the same manner as the lift, by toggling its movement with a controller button.\hypertarget{clawbot_autotoc_md89}{}\doxysubsubsection{Reading the Switches}\label{clawbot_autotoc_md89}
The bump switches, or buttons, are plugged into the A\+DI and attached to the rear of the robot. We\textquotesingle{}ll monitor the status of the bump switches, and prevent the robot from driving backwards if the switches are pressed.

We will be using the digital reading functionality of the A\+DI for this.

And here is the updated code\+:

We will use a similar technique for reading the limit switch. If the limit switch is pressed, then we will prevent the lift from being driven down further.\hypertarget{clawbot_autotoc_md90}{}\doxysubsubsection{Simple Autonomous}\label{clawbot_autotoc_md90}
The autonomous program runs without the use of a controller. We will make a simple autonomous program that drives straight. \hypertarget{creating-c-project}{}\doxysection{Creating a C Project}\label{creating-c-project}
By default, a new P\+R\+OS project contains C++ source files and the C++ A\+PI. If you would prefer to program in C instead, change the extension of the source files (prior to P\+R\+OS kernel 3.\+2.\+0\+: {\ttfamily initialize.\+cpp}, {\ttfamily autonomous.\+cpp}, and {\ttfamily opcontrol.\+cpp}; after P\+R\+OS kernel 3.\+2.\+0\+: {\ttfamily main.\+cpp}) to {\ttfamily .c}.

\begin{DoxyWarning}{Warning}
Do not change any of the P\+R\+OS header files in this process. That will cause the wrong files to be included in your project, and will likely prevent compilation. Only modify the extensions of the {\ttfamily .cpp} files.
\end{DoxyWarning}
This will compile your P\+R\+OS project as C code, and will give you access to the \href{../../api/c/index.html}{\texttt{ C A\+PI}}.

If you\textquotesingle{}re interested in combining C and C++, you should read through the \href{../general/combining-c-cpp.html}{\texttt{ Combining C and C++ tutorial}}. Please note that it is typically a complicated matter to combine the two, and rarely a good idea. 