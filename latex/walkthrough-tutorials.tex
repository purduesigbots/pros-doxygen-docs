If you want to write full sample programs to learn to use P\+R\+OS through practical applications, or teach students to use P\+R\+OS in a classroom environment, the {\bfseries{Walkthrough Tutorials}} are a great resource to go step by step through the process of writing a P\+R\+OS program.


\begin{DoxyItemize}
\item \mbox{\hyperlink{clawbot}{Programming the Clawbot}}
\item \mbox{\hyperlink{creating-c-project}{Creating a C Project}} 
\end{DoxyItemize}\hypertarget{clawbot}{}\doxysection{Programming the Clawbot}\label{clawbot}
\hypertarget{clawbot_autotoc_md66}{}\doxysubsubsection{Objective}\label{clawbot_autotoc_md66}
This tutorial will guide you through basic programming of the V\+EX Clawbot.\hypertarget{clawbot_autotoc_md67}{}\doxysubsubsection{Intended Audience}\label{clawbot_autotoc_md67}
This tutorial is intended for developers with some programming experience, but with little to no experience with the P\+R\+OS library. If you haven\textquotesingle{}t programmed before, we recommend checking out all the \char`\"{}\+Introduction and Basic C Features\char`\"{} sections of \href{http://www.studytonight.com/c/overview-of-c.php}{\texttt{ this tutorial series}}; you may also benefit from the \char`\"{}\+Pointers, Arrays and Strings\char`\"{} sections as well (although they aren\textquotesingle{}t as pertinent).\hypertarget{clawbot_autotoc_md68}{}\doxysubsubsection{Goals}\label{clawbot_autotoc_md68}
At the end of this tutorial you will have\+:


\begin{DoxyItemize}
\item Understood the basic project structure of P\+R\+OS
\item Programmed a basic chassis with \char`\"{}tank\char`\"{} control or \char`\"{}arcade\char`\"{} control
\item Programmed buttons to control the clawbot\textquotesingle{}s lift
\item Programmed a joystick axis to control the clawbot\textquotesingle{}s claw
\item Understood the standard subsystem module methodology
\item Programmed a dead-\/reckoned autonomous routine
\end{DoxyItemize}\hypertarget{clawbot_autotoc_md69}{}\doxysubsubsection{The Clawbot}\label{clawbot_autotoc_md69}
Here\textquotesingle{}s the robot we\textquotesingle{}ll be programming\+:

 
\begin{DoxyImageNoCaption}
  \mbox{\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{clawbot1.jpg}}
\end{DoxyImageNoCaption}
  

You can follow V\+EX\textquotesingle{}s tutorial for building this robot \href{https://v5beta.vex.com/parent-wrapper.php?id=v5-with-clawbot}{\texttt{ here}}.

For the purposes of this tutorial, we\textquotesingle{}ve plugged in our motors into the following ports\+:

Port Description Port Description

\DoxyHorRuler{0}


1 Left Wheels 11 ~\newline
 2 12 ~\newline
 3 Claw Motor 13 ~\newline
 4 14 ~\newline
 5 Vision Sensor 15 ~\newline
 6 16 ~\newline
 7 17 ~\newline
 8 Arm Motor 18 ~\newline
 9 19 ~\newline
 10 Right Wheels 20

Port 21\+: Radio

For the A\+DI\+:

Port Description Port Description

\DoxyHorRuler{0}


A Left Bumper E ~\newline
 B Right Bumper F ~\newline
 C G ~\newline
 D H Arm Limit\hypertarget{clawbot_autotoc_md72}{}\doxysubsubsection{Creating the Project}\label{clawbot_autotoc_md72}
With Atom started, you can create a new P\+R\+OS project by clicking the {\ttfamily P\+R\+OS} menu, then click {\ttfamily Create new Project}.

Create a directory that you\textquotesingle{}d like to keep the source files for your Clawbot project.

Pick a directory to create the new project in and click Create. The P\+R\+OS C\+LI will now copy the latest kernel template into the specified directory and Atom will open it.\hypertarget{clawbot_autotoc_md73}{}\doxysubsubsection{P\+R\+O\+S Project Structure}\label{clawbot_autotoc_md73}
When you create your project, P\+R\+OS will copy all of the files necessary to build your project. The structure of the project looks like\+:

\begin{DoxyNote}{Note}
Prior to P\+R\+OS kernel 3.\+2.\+0, the {\ttfamily \mbox{\hyperlink{main_8h_a1903abdb5ef0f301d660754c8315fc17}{opcontrol()}}}, {\ttfamily \mbox{\hyperlink{main_8h_a2df3d06bc5bced154da27fce393f991f}{autonomous()}}}, and initialize functions are separated into separate files (opcontrol.\+cpp, autonomous.\+cpp, and initialize.\+cpp). After P\+R\+OS kernel 3.\+2.\+0, they are by default kept in one file (main.\+cpp). These could be separated again if you so wish.
\end{DoxyNote}
\hypertarget{clawbot_autotoc_md74}{}\doxysubsubsection{Drive Control}\label{clawbot_autotoc_md74}
Let\textquotesingle{}s start with the simplest operator control setup for the clawbot -\/ tank drive control. We\textquotesingle{}ll map the controller\textquotesingle{}s left joystick to the left drive motor and the controller\textquotesingle{}s right joystick to the right drive motor.

The controller joystick can be read with the following function\+:

And we\textquotesingle{}ll set the motors with the following function\+:

Before we get started with the tank drive control, it\textquotesingle{}s important to note that in C++, smart devices have constructors that create the smart device object. Constructors are a standard C++ concept, and they\textquotesingle{}re very important because a constructor is necessary to define a class for objects like the motors and controllers.

We\textquotesingle{}ll be calling the constructors for the motors and controller at the beginning of {\ttfamily \mbox{\hyperlink{main_8h_a1903abdb5ef0f301d660754c8315fc17}{opcontrol()}}}, and then we\textquotesingle{}ll run the tank drive code.

To test this code, run the following commands in the terminal window to create, build, and upload the code.

These 2 commands can be simplified to {\ttfamily \`{}prosv5 mu}.\hypertarget{clawbot_autotoc_md75}{}\doxysubsubsection{Arcade Control}\label{clawbot_autotoc_md75}
While tank drive control is perfectly suitable for the driving style of some individuals, it is worth covering the arcade control method as well. This is similar to the movement style of many video games, where one joystick axis covers forward/backward movement and the other joystick covers turning.

We will take the previous tank drive control code and modify it slightly to become arcade control. The sum or difference of the power and turn joysticks will be the power values sent to the left and right wheels.

As with the tank drive code, this can be uploaded with the {\ttfamily prosv5 mu} command.\hypertarget{clawbot_autotoc_md76}{}\doxysubsubsection{Arm Control}\label{clawbot_autotoc_md76}
Next let\textquotesingle{}s control the clawbot\textquotesingle{}s arm. This will not require the use of a joystick, but instead we will use the controller\textquotesingle{}s buttons.

We will use the following function to read the button press from the controller\+:

We will use a different motor movement function than on the drivetrain. By using the velocity-\/controlled movement functions, we can ensure that the lift moves at a constant speed regardless of the weight that the lift is holding.

To actuate the lift, we will check if the upmost right trigger is pressed or if the bottommost right trigger is pressed on the controller, and move the lift in that direction if so.\hypertarget{clawbot_autotoc_md77}{}\doxysubsubsection{Claw Control}\label{clawbot_autotoc_md77}
We will control the claw in the same manner as the lift, by toggling its movement with a controller button.\hypertarget{clawbot_autotoc_md78}{}\doxysubsubsection{Reading the Switches}\label{clawbot_autotoc_md78}
The bump switches, or buttons, are plugged into the A\+DI and attached to the rear of the robot. We\textquotesingle{}ll monitor the status of the bump switches, and prevent the robot from driving backwards if the switches are pressed.

We will be using the digital reading functionality of the A\+DI for this.

And here is the updated code\+:

We will use a similar technique for reading the limit switch. If the limit switch is pressed, then we will prevent the lift from being driven down further.\hypertarget{clawbot_autotoc_md79}{}\doxysubsubsection{Simple Autonomous}\label{clawbot_autotoc_md79}
The autonomous program runs without the use of a controller. We will make a simple autonomous program that drives straight. \hypertarget{creating-c-project}{}\doxysection{Creating a C Project}\label{creating-c-project}
By default, a new P\+R\+OS project contains C++ source files and the C++ A\+PI. If you would prefer to program in C instead, change the extension of the source files (prior to P\+R\+OS kernel 3.\+2.\+0\+: {\ttfamily initialize.\+cpp}, {\ttfamily autonomous.\+cpp}, and {\ttfamily opcontrol.\+cpp}; after P\+R\+OS kernel 3.\+2.\+0\+: {\ttfamily main.\+cpp}) to {\ttfamily .c}.

\begin{DoxyWarning}{Warning}
Do not change any of the P\+R\+OS header files in this process. That will cause the wrong files to be included in your project, and will likely prevent compilation. Only modify the extensions of the {\ttfamily .cpp} files.
\end{DoxyWarning}
This will compile your P\+R\+OS project as C code, and will give you access to the \href{../../api/c/index.html}{\texttt{ C A\+PI}}.

If you\textquotesingle{}re interested in combining C and C++, you should read through the \mbox{\hyperlink{combining-c-cpp}{Combining C and C++}}. Please note that it is typically a complicated matter to combine the two, and rarely a good idea. 